(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.collide=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (process){
// Generated by CoffeeScript 1.6.3
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/*
*/

}).call(this,_dereq_("qhDIRT"))
},{"qhDIRT":13}],2:[function(_dereq_,module,exports){
var now = _dereq_('performance-now')
  , global = typeof window === 'undefined' ? {} : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = global['request' + suffix]
  , caf = global['cancel' + suffix] || global['cancelRequest' + suffix]

for(var i = 0; i < vendors.length && !raf; i++) {
  raf = global[vendors[i] + 'Request' + suffix]
  caf = global[vendors[i] + 'Cancel' + suffix]
      || global[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            cp[i].callback(last)
          }
        }
      }, next)
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function() {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.apply(global, arguments)
}
module.exports.cancel = function() {
  caf.apply(global, arguments)
}

},{"performance-now":3}],3:[function(_dereq_,module,exports){
module.exports=_dereq_(1)
},{"qhDIRT":13}],4:[function(_dereq_,module,exports){

// Interpolation disabled for now
// var interpolate = require('./core/interpolate');
// var cssFeature = require('feature/css');

var timeline = _dereq_('./core/timeline');
var dynamics = _dereq_('./core/dynamics');
var easingFunctions = _dereq_('./core/easing-functions');

var uid = _dereq_('./util/uid');
var EventEmitter = _dereq_('./util/simple-emitter');

function clamp(min, n, max) { return Math.max(min, Math.min(n, max)); }

var VELOCITY_MIN = 0.0075;

module.exports = Animation;

function Animation(opts) {
  //if `new` keyword isn't provided, do it for user
  if (!(this instanceof Animation)) {
    return new Animation(opts);
  }
  var self = this;


  opts = opts || {};

  //Private state goes in this._
  this._ = {
    id: uid(),
    percent: 0,
    duration: 500,
    reverse: false,
    distance: 100,
    deceleration: 0.998
  };

  var emitter = this._.emitter = new EventEmitter();
  this._.onDestroy = function() {
    emitter.emit('destroy');
  };
  this._.onStop = function(wasCompleted) {
    emitter.emit('stop', wasCompleted);
    wasCompleted && emitter.emit('complete');
  };
  this._.onStart = function() {
    emitter.emit('start');
  };

  var precision = 10000;
  this._.onStep = function(v) {
    emitter.emit('step', Math.round(v * precision) / precision);
  };

  opts.duration && this.duration(opts.duration);
  opts.percent && this.percent(opts.percent);
  opts.easing && this.easing(opts.easing);
  opts.reverse && this.reverse(opts.reverse);
  opts.distance && this.distance(opts.distance);
 
  //Put this here so we don't have to call _tick in the context of our object.
  //Avoids having to use .bind() or .call() every frame.
  self._tick = function(deltaT) {
    var state = self._;
    
    state.onStep(animStepValue(self, state.percent));

    if (Math.abs(state.velocity) < VELOCITY_MIN) {
      state.velocity = 0;
      return self.stop();
    }
    if (state.percent === animEndPercent(self)) {
      return self.stop();
    }

    //First tick, don't up the percent
    if (!deltaT) {
      // Do nothing
    } else if (state.velocity) {
      var velocity = decayVelocity(state.velocity, deltaT, state.deceleration);
      var currentDistance = state.percent * state.distance;
      state.percent = (currentDistance - velocity) / state.distance;

      if (state.percent > 1 || state.percent < 0) {
        state.percent = clamp(0, state.percent, 1);
        state.velocity = 0;
      }
      state.velocity = velocity;
    } else {
      if (state.reverse) {
        state.percent = state.percent - (deltaT / state.duration);
      } else {
        state.percent = state.percent + (deltaT / state.duration);
      }
    }

    state.percent = clamp(0, state.percent, 1);
  };
}

Animation.prototype = {
  reverse: function(reverse) {
    if (arguments.length) {
      this._.reverse = !!reverse;
      return this;
    }
    return this._.reverse;
  },

  easing: function(easing) {
    var type = typeof easing;
    if (arguments.length) {
      if (type === 'function' || type === 'string' || type === 'object') {
        this._.easing = figureOutEasing(easing);
      }
      return this;
    }
    return this._.easing;
  },

  percent: function(percent, immediate) {
    var self = this;
    if (arguments.length) {
      if (typeof percent === 'number') {
        this._.percent = clamp(0, percent, 1);
      }
      if (!this.isRunning()) {
        if (immediate) {
          this._tick();
        } else {
          timeline.tickAction(this._.id, function() {
            self._tick();
            timeline.untickAction(self._.id);
          });
        }
      }
      return this;
    }
    return this._.percent;
  },

  distance: function(distance) {
    if (arguments.length) {
      if (typeof distance === 'number' && distance > 0) {
        this._.distance = distance;
      }
      return this;
    }
    return this._.distance;
  },

  deceleration: function(deceleration) {
    if (arguments.length) {
      if (typeof deceleration === 'number' && deceleration > 0 && deceleration < 1) {
        this._.deceleration = deceleration;
      }
      return this;
    }
    return this._.deceleration;
  },

  duration: function(duration) {
    if (arguments.length) {
      if (typeof duration === 'number' && duration > 0) {
        this._.duration = duration;
      }
      return this;
    }
    return this._.duration;
  },

  isRunning: function() { 
    return !!this._.isRunning; 
  },

  promise: function() {
    var self = this;
    return {
      then: function(cb) {
        self.once('stop', cb);
      }
    };
  },

  on: function(eventType, listener) {
    this._.emitter.on(eventType, listener);
    return this;
  },
  once: function(eventType, listener) {
    this._.emitter.once(eventType, listener);
    return this;
  },
  off: function(eventType, listener) {
    this._.emitter.off(eventType, listener);
    return this;
  },

  destroy: function() {
    this.stop();
    this._.onDestroy();
    this.off();
    return this;
  },

  stop: function() {
    if (!this._.isRunning) return;

    this._.isRunning = false;
    timeline.untickAction(this._.id);

    this._.onStop(animIsComplete(this));
    return this;
  },

  restart: function(immediate) {
    if (this._.isRunning) return;

    this._.percent = animStartPercent(this);

    return this.start(!!immediate);
  },

  start: function(immediate) {
    return animBegin(this, immediate);
  },

  velocity: function(velocity, immediate) {
    this._.velocity = velocity;
    return animBegin(this, immediate);
  },
};

function animBegin(animation, immediate) {
  if (immediate) {
    animation._tick();
  }

  animation._.isRunning = true;
  timeline.tickAction(animation._.id, animation._tick);

  animation._.onStart();
  return animation;
}
function animIsComplete(animation) {
  return !animation._.isRunning && 
    animation._.percent === animEndPercent(animation);
}
function animEndPercent(animation) {
  return animation._.reverse ? 0 : 1;
}
function animStartPercent(animation) {
  return animation._.reverse ? 1 : 0;
}
function animStepValue(animation, value) {
  if (animation._.easing) {
    return animation._.easing(value, animation._.duration);
  }
  return value;
}

function decayVelocity(velocity, dt, deceleration) {
  var kv = Math.pow(deceleration, dt);
  return velocity * kv;
}

function figureOutEasing(easing) {
  if (typeof easing === 'object') {
    var dynamicType = typeof easing.type === 'string' &&
      easing.type.toLowerCase().trim();

    if (!dynamics[dynamicType]) {
      throw new Error(
        'Invalid easing dynamics object type "' + easing.type + '". ' +
        'Available dynamics types: ' + Object.keys(dynamics).join(', ') + '.'
      );
    }
    return dynamics[dynamicType](easing);

  } else if (typeof easing === 'string') {
    easing = easing.toLowerCase().trim();
    
    if (easing.indexOf('cubic-bezier(') === 0) {
      var parts = easing
        .replace('cubic-bezier(', '')
        .replace(')', '')
        .split(',')
        .map(function(v) {
          return v.trim();
        });
      return easingFunctions['cubic-bezier'](parts[0], parts[1], parts[2], parts[3]);
    } else {
      var fn = easingFunctions[easing];
      if (!fn) {
        throw new Error(
          'Invalid easing function "' + easing + '". ' +
          'Available easing functions: ' + Object.keys(easingFunctions).join(', ') + '.'
        );
      }
      return easingFunctions[easing]();
    }
  } else if (typeof easing === 'function') {
    return easing;
  }
}

// /*
//  * Tweening helpers
//  */
// function syncStyles(startingStyles, endingStyles, computedStyle) {
//   var property;
//   for (property in startingStyles) {
//     if (!endingStyles.hasOwnProperty(property)) {
//       delete startingStyles[property];
//     }
//   }
//   for (property in endingStyles) {
//     if (!startingStyles.hasOwnProperty(property)) {
//       startingStyles[property] = computedStyle[vendorizePropertyName(property)];
//     }
//   }
// }

// function makePropertyInterpolators(startingStyles, endingStyles) {
//   var interpolators = {};
//   var property;
//   for (property in startingStyles) {
//     interpolators[vendorizePropertyName(property)] = interpolate.propertyInterpolator(
//       property, startingStyles[property], endingStyles[property]
//     );
//   }
//   return interpolators;
// }

// var transformProperty;
// function vendorizePropertyName(property) {
//   if (property === 'transform') {
//     //Set transformProperty lazily, to be sure DOM has loaded already when using it
//     return transformProperty || 
//       (transformProperty = cssFeature('transform').property);
//   } else {
//     return property;
//   }
// }

},{"./core/dynamics":6,"./core/easing-functions":7,"./core/timeline":8,"./util/simple-emitter":11,"./util/uid":12}],5:[function(_dereq_,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// http://www.w3.org/TR/css3-transitions/#transition-easing-function
module.exports =  {
  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  linear: unitBezier(0.0, 0.0, 1.0, 1.0),

  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  ease: unitBezier(0.25, 0.1, 0.25, 1.0),

  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  easeIn: unitBezier(0.42, 0, 1.0, 1.0),

  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  easeOut: unitBezier(0, 0, 0.58, 1.0),

  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  easeInOut: unitBezier(0.42, 0, 0.58, 1.0),

  /*
   * @param p1x {number} X component of control point 1
   * @param p1y {number} Y component of control point 1
   * @param p2x {number} X component of control point 2
   * @param p2y {number} Y component of control point 2
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  cubicBezier: function(p1x, p1y, p2x, p2y) {
    return unitBezier(p1x, p1y, p2x, p2y);
  }
};

function B1(t) { return t*t*t; }
function B2(t) { return 3*t*t*(1-t); }
function B3(t) { return 3*t*(1-t)*(1-t); }
function B4(t) { return (1-t)*(1-t)*(1-t); }

/*
 * JavaScript port of Webkit implementation of CSS cubic-bezier(p1x.p1y,p2x,p2y) by http://mck.me
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

/*
 * Duration value to use when one is not specified (400ms is a common value).
 * @const
 * @type {number}
 */
var DEFAULT_DURATION = 400;//ms

/*
 * The epsilon value we pass to UnitBezier::solve given that the animation is going to run over |dur| seconds.
 * The longer the animation, the more precision we need in the easing function result to avoid ugly discontinuities.
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/page/animation/AnimationBase.cpp
 */
function solveEpsilon(duration) {
  return 1.0 / (200.0 * duration);
}

/*
 * Defines a cubic-bezier curve given the middle two control points.
 * NOTE: first and last control points are implicitly (0,0) and (1,1).
 * @param p1x {number} X component of control point 1
 * @param p1y {number} Y component of control point 1
 * @param p2x {number} X component of control point 2
 * @param p2y {number} Y component of control point 2
 */
function unitBezier(p1x, p1y, p2x, p2y) {

  // private members --------------------------------------------

  // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).

  /*
   * X component of Bezier coefficient C
   * @const
   * @type {number}
   */
  var cx = 3.0 * p1x;

  /*
   * X component of Bezier coefficient B
   * @const
   * @type {number}
   */
  var bx = 3.0 * (p2x - p1x) - cx;

  /*
   * X component of Bezier coefficient A
   * @const
   * @type {number}
   */
  var ax = 1.0 - cx -bx;

  /*
   * Y component of Bezier coefficient C
   * @const
   * @type {number}
   */
  var cy = 3.0 * p1y;

  /*
   * Y component of Bezier coefficient B
   * @const
   * @type {number}
   */
  var by = 3.0 * (p2y - p1y) - cy;

  /*
   * Y component of Bezier coefficient A
   * @const
   * @type {number}
   */
  var ay = 1.0 - cy - by;

  /*
   * @param t {number} parametric easing value
   * @return {number}
   */
  var sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((ax * t + bx) * t + cx) * t;
  };

  /*
   * @param t {number} parametric easing value
   * @return {number}
   */
  var sampleCurveY = function(t) {
    return ((ay * t + by) * t + cy) * t;
  };

  /*
   * @param t {number} parametric easing value
   * @return {number}
   */
  var sampleCurveDerivativeX = function(t) {
    return (3.0 * ax * t + 2.0 * bx) * t + cx;
  };

  /*
   * Given an x value, find a parametric value it came from.
   * @param x {number} value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param epsilon {number} accuracy limit of t for the given x
   * @return {number} the t value corresponding to x
   */
  var solveCurveX = function(x, epsilon) {
    var t0;
    var t1;
    var t2;
    var x2;
    var d2;
    var i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {
      x2 = sampleCurveX(t2) - x;
      if (Math.abs (x2) < epsilon) {
        return t2;
      }
      d2 = sampleCurveDerivativeX(t2);
      if (Math.abs(d2) < 1e-6) {
        break;
      }
      t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }

    while (t0 < t1) {
      x2 = sampleCurveX(t2);
      if (Math.abs(x2 - x) < epsilon) {
        return t2;
      }
      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }
      t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
  };

  /*
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param epsilon {number} the accuracy of t for the given x
   * @return {number} the y value along the bezier curve
   */
  var solve = function(x, epsilon) {
    return sampleCurveY(solveCurveX(x, epsilon));
  };

  // public interface --------------------------------------------

  /*
   * Find the y of the cubic-bezier for a given x with accuracy determined by the animation duration.
   * @param x {number} the value of x along the bezier curve, 0.0 <= x <= 1.0
   * @param duration {number} the duration of the animation in milliseconds
   * @return {number} the y value along the bezier curve
   */
  return function(x, duration) {
    return solve(x, solveEpsilon(+duration || DEFAULT_DURATION));
  };
}


},{}],6:[function(_dereq_,module,exports){
/**
 * A HUGE thank you to dynamics.js which inspired these dynamics simulations.
 * https://github.com/michaelvillar/dynamics.js
 *
 * Also licensed under MIT
 */

var extend = _dereq_('../util/extend');

module.exports = {
  spring: dynamicsSpring,
  gravity: dynamicsGravity
};

var springDefaults = {
  frequency: 15,
  friction: 200,
  anticipationStrength: 0,
  anticipationSize: 0
};
function dynamicsSpring(opts) {
  opts = extend({}, springDefaults, opts || {});

  return function at(t, duration) {
    var A, At, a, angle, b, decal, frequency, friction, frictionT, s, v, y0, yS,
    _opts = opts;
    frequency = Math.max(1, opts.frequency);
    friction = Math.pow(20, opts.friction / 100);
    s = opts.anticipationSize / 100;
    decal = Math.max(0, s);
    frictionT = (t / (1 - s)) - (s / (1 - s));
    if (t < s) {
      A = function(t) {
        var M, a, b, x0, x1;
        M = 0.8;
        x0 = s / (1 - s);
        x1 = 0;
        b = (x0 - (M * x1)) / (x0 - x1);
        a = (M - b) / x0;
        return (a * t * _opts.anticipationStrength / 100) + b;
      };
      yS = (s / (1 - s)) - (s / (1 - s));
      y0 = (0 / (1 - s)) - (s / (1 - s));
      b = Math.acos(1 / A(yS));
      a = (Math.acos(1 / A(y0)) - b) / (frequency * (-s));
    } else {
      A = function(t) {
        return Math.pow(friction / 10, -t) * (1 - t);
      };
      b = 0;
      a = 1;
    }
    At = A(frictionT);
    angle = frequency * (t - s) * a + b;
    v = 1 - (At * Math.cos(angle));
    //return [t, v, At, frictionT, angle];
    return v;
  };
}

var gravityDefaults = {
  bounce: 40,
  gravity: 1000,
  initialForce: false
};
function dynamicsGravity(opts) {
  opts = extend({}, gravityDefaults, opts || {});
  var curves = [];

  init();

  return at;

  function length() {
    var L, b, bounce, curve, gravity;
    bounce = Math.min(opts.bounce / 100, 80);
    gravity = opts.gravity / 100;
    b = Math.sqrt(2 / gravity);
    curve = {
      a: -b,
      b: b,
      H: 1
    };
    if (opts.initialForce) {
      curve.a = 0;
      curve.b = curve.b * 2;
    }
    while (curve.H > 0.001) {
      L = curve.b - curve.a;
      curve = {
        a: curve.b,
        b: curve.b + L * bounce,
        H: curve.H * bounce * bounce
      };
    }
    return curve.b;
  }

  function init() {
    var L, b, bounce, curve, gravity, _results;

    L = length();
    gravity = (opts.gravity / 100) * L * L;
    bounce = Math.min(opts.bounce / 100, 80);
    b = Math.sqrt(2 / gravity);
    curves = [];
    curve = {
      a: -b,
      b: b,
      H: 1
    };
    if (opts.initialForce) {
      curve.a = 0;
      curve.b = curve.b * 2;
    }
    curves.push(curve);
    _results = [];
    while (curve.b < 1 && curve.H > 0.001) {
      L = curve.b - curve.a;
      curve = {
        a: curve.b,
        b: curve.b + L * bounce,
        H: curve.H * bounce * bounce
      };
      _results.push(curves.push(curve));
    }
    return _results;
  }

  function calculateCurve(a, b, H, t){
    var L, c, t2;
    L = b - a;
    t2 = (2 / L) * t - 1 - (a * 2 / L);
    c = t2 * t2 * H - H + 1;
    if (opts.initialForce) {
      c = 1 - c;
    }
    return c;
  }

  function at(t, duration) {
    var bounce, curve, gravity, i, v;
    bounce = opts.bounce / 100;
    gravity = opts.gravity;
    i = 0;
    curve = curves[i];
    while (!(t >= curve.a && t <= curve.b)) {
      i += 1;
      curve = curves[i];
      if (!curve) {
        break;
      }
    }
    if (!curve) {
      v = opts.initialForce ? 0 : 1;
    } else {
      v = calculateCurve(curve.a, curve.b, curve.H, t);
    }
    //return [t, v];
    return v;
  }

};

},{"../util/extend":10}],7:[function(_dereq_,module,exports){
var dynamics = _dereq_('./dynamics');
var bezier = _dereq_('./bezier');

module.exports = {
  'linear': function() {
    return function(t, duration) {
      return bezier.linear(t, duration);
    };
  },
  'ease': function() {
    return function(t, duration) {
      return bezier.ease(t, duration);
    };
  },
  'ease-in': function() {
    return function(t, duration) {
      return bezier.easeIn(t, duration);
    };
  },
  'ease-out': function() {
    return function(t, duration) {
      return bezier.easeOut(t, duration);
    };
  },
  'ease-in-out': function() {
    return function(t, duration) {
      return bezier.easeInOut(t, duration);
    };
  },
  'cubic-bezier': function(x1, y1, x2, y2, duration) {
    var bz = bezier.cubicBezier(x1, y1, x2, y2);//, t, duration);
    return function(t, duration) {
      return bz(t, duration);
    };
  }
};

},{"./bezier":5,"./dynamics":6}],8:[function(_dereq_,module,exports){

var raf = _dereq_('raf');
var time = _dereq_('performance-now');

var self = module.exports = {
  _actions: {},
  isTicking: false,

  tickAction: function(id, action) {
    self._actions[id] = action;

    if (!self.isTicking) {
      self.tick();
    }
  },

  untickAction: function(id) {
    delete self._actions[id];
    self.maybeStopTicking();
  },

  tick: function() {
    var lastFrame = time();

    self.isTicking = true;
    self._rafId = raf(step);

    function step() {
      self._rafId = raf(step);

      // Get current time
      var now = time();
      var deltaT = now - lastFrame;

      for (var id in self._actions) {
        self._actions[id](deltaT);
      }

      lastFrame = now;
    }
  },

  maybeStopTicking: function() {
    if (self.isTicking && !Object.keys(self._actions).length) {
      raf.cancel(self._rafId);
      self.isTicking = false;
    }
  },

};


},{"performance-now":1,"raf":2}],9:[function(_dereq_,module,exports){
module.exports = {
  animation: _dereq_('./animation')
};

},{"./animation":4}],10:[function(_dereq_,module,exports){

/*
 * There really is no tiny minimal extend() on npm to find,
 * so we just use our own.
 */

module.exports = function extend(obj) {
   var args = Array.prototype.slice.call(arguments, 1);
   for(var i = 0; i < args.length; i++) {
     var source = args[i];
     if (source) {
       for (var prop in source) {
         obj[prop] = source[prop];
       }
     }
   }
   return obj;
};

},{}],11:[function(_dereq_,module,exports){

// All we want is an eventEmitter that doesn't use #call or #apply,
// by expecting 0-1 arguments. 
// We couldn't find this on npm, so we make our own.

module.exports = SimpleEventEmitter;

function SimpleEventEmitter() {
  this.listeners = [];
}

SimpleEventEmitter.prototype = {
  on: function(eventType, fn) {
    if (typeof fn !== 'function') return;
    this.listeners[eventType] || (this.listeners[eventType] = []);
    this.listeners[eventType].push(fn);
  },
  once: function(eventType, fn) {
    var self = this;
    function onceFn() {
      self.off(eventType, fn);
      self.off(eventType, onceFn);
    }
    this.on(eventType, fn);
    this.on(eventType, onceFn);
  },
  // Built-in limitation: we only expect 0-1 arguments
  // This is to save as much perf as possible when sending
  // events every frame.
  emit: function(eventType, eventArg) {
    var listeners = this.listeners[eventType] || [];
    var i = 0;
    var len = listeners.length;
    if (arguments.length === 2) {
      for (i; i < len; i++) listeners[i] && listeners[i](eventArg);
    } else {
      for (i; i < len; i++) listeners[i] && listeners[i]();
    }
  },
  off: function(eventType, fnToRemove) {
    if (!eventType) {
      //Remove all listeners
      for (var type in this.listeners) {
        this.off(type);
      }
    } else  {
      var listeners = this.listeners[eventType];
      if (listeners) {
        if (!fnToRemove) {
          listeners.length = 0;
        } else {
          var index = listeners.indexOf(fnToRemove);
          listeners.splice(index, 1);
        }
      }
    }
  } 
};

},{}],12:[function(_dereq_,module,exports){

/**
 * nextUid() from angular.js
 * License MIT
 * http://github.com/angular/angular.js
 *
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
 * characters such as '012ABC'. The reason why we are not using simply a number counter is that
 * the number string gets longer over time, and it can also overflow, where as the nextId
 * will grow much slower, it is a string, and it will never overflow.
 *
 * @returns an unique alpha-numeric string
 */
var uid = [];

module.exports = function nextUid() {
  var index = uid.length;
  var digit;

  while(index) {
    index--;
    digit = uid[index].charCodeAt(0);
    if (digit == 57 /*'9'*/) {
      uid[index] = 'A';
      return uid.join('');
    }
    if (digit == 90  /*'Z'*/) {
      uid[index] = '0';
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join('');
    }
  }
  uid.unshift('0');
  return uid.join('');
};

},{}],13:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}]},{},[9])
(9)
});

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/bower_components\\collide\\collide.js","/bower_components\\collide")
},{"VCmEsw":12,"buffer":9}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
(function(ionic) {

  // Get transform origin poly
  var d = document.createElement('div');
  var transformKeys = ['webkitTransformOrigin', 'transform-origin', '-webkit-transform-origin', 'webkit-transform-origin',
              '-moz-transform-origin', 'moz-transform-origin', 'MozTransformOrigin', 'mozTransformOrigin'];

  var TRANSFORM_ORIGIN = 'webkitTransformOrigin';
  for(var i = 0; i < transformKeys.length; i++) {
    if(d.style[transformKeys[i]] !== undefined) {
      TRANSFORM_ORIGIN = transformKeys[i];
      break;
    }
  }

  var transitionKeys = ['webkitTransition', 'transition', '-webkit-transition', 'webkit-transition',
              '-moz-transition', 'moz-transition', 'MozTransition', 'mozTransition'];
  var TRANSITION = 'webkitTransition';
  for(var i = 0; i < transitionKeys.length; i++) {
    if(d.style[transitionKeys[i]] !== undefined) {
      TRANSITION = transitionKeys[i];
      break;
    }
  }

  var SwipeableCardView = ionic.views.View.inherit({
    /**
     * Initialize a card with the given options.
     */
    initialize: function(opts) {
      opts = ionic.extend({
      }, opts);

      ionic.extend(this, opts);

      this.el = opts.el;

      this.parentWidth = this.el.parentNode.offsetWidth;
      this.width = this.el.offsetWidth;

      this.startX = this.startY = this.x = this.y = 0;

      this.bindEvents();
    },

    /**
     * Set the X position of the card.
     */
    setX: function(x) {
      this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px,' + this.y + 'px, 0)';
      this.x = x;
      this.startX = x;
    },

    /**
     * Set the Y position of the card.
     */
    setY: function(y) {
      this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + this.x + 'px,' + y + 'px, 0)';
      this.y = y;
      this.startY = y;
    },

    /**
     * Set the Z-Index of the card
     */
    setZIndex: function(index) {
      this.el.style.zIndex = index;
    },

    /**
     * Set the width of the card
     */
    setWidth: function(width) {
      this.el.style.width = width + 'px';
    },

    /**
     * Set the height of the card
     */
    setHeight: function(height) {
      this.el.style.height = height + 'px';
    },

    /**
     * Set the duration to run the pop-in animation
     */
    setPopInDuration: function(duration) {
      this.cardPopInDuration = duration;
    },

    /**
     * Transition in the card with the given animation class
     */
    transitionIn: function(animationClass) {
      var self = this;

      this.el.classList.add(animationClass + '-start');
      this.el.classList.add(animationClass);
      this.el.style.display = 'block';
      setTimeout(function() {
        self.el.classList.remove(animationClass + '-start');
      }, 100);
    },

    /**
     * Disable transitions on the card (for when dragging)
     */
    disableTransition: function(animationClass) {
      this.el.classList.remove(animationClass);
    },

    /**
     * Swipe a card out programtically
     */
    swipe: function() {
      this.transitionOut();
    },
    
    /**
     * Snap the card back to its original position
     */
    snapBack: function() {
      this.onSnapBack(this.x, this.y, this.rotationAngle);
    },

    isUnderThreshold: function() {
      //return true;
      return Math.abs(this.thresholdAmount) < 0.4;
    },
    /**
     * Fly the card out or animate back into resting position.
     */
    transitionOut: function(e) {
      var self = this;

      if(this.isUnderThreshold()) {
        self.onSnapBack(this.x, this.y, this.rotationAngle);
        return;
      }

      self.onTransitionOut(self.thresholdAmount);
      
      var angle = Math.atan(e.gesture.deltaX / e.gesture.deltaY);

      var dir = this.thresholdAmount < 0 ? -1 : 1;
      var targetX;
      if(this.x > 0) {
        targetX = (this.parentWidth / 2) + (this.width);
      } else {
        targetX = - (this.parentWidth + this.width);
      }

      // Target Y is just the "opposite" side of the triangle of targetX as the adjacent edge (sohcahtoa yo)
      var targetY = targetX / Math.tan(angle);

      // Fly out
      var rotateTo = this.rotationAngle;//(this.rotationAngle this.rotationDirection * 0.2));// || (Math.random() * 0.4);

      var duration = 0.3 - Math.min(Math.max(Math.abs(e.gesture.velocityX)/10, 0.05), 0.2);
      
      ionic.requestAnimationFrame(function() {
        self.el.style.transform = self.el.style.webkitTransform = 'translate3d(' + targetX + 'px, ' + targetY + 'px,0) rotate(' + self.rotationAngle + 'rad)';
        self.el.style.transition = self.el.style.webkitTransition = 'all ' + duration + 's ease-in-out';
      });

      //this.onSwipe && this.onSwipe();

      // Trigger destroy after card has swiped out
      setTimeout(function() {
        self.onDestroy && self.onDestroy();
      }, duration * 1000);
    },

    /**
     * Bind drag events on the card.
     */
    bindEvents: function() {
      var self = this;
      ionic.onGesture('dragstart', function(e) {
        /*
        var cx = window.innerWidth / 2;
        if(e.gesture.touches[0].pageX < cx) {
          self._transformOriginRight();
        } else {
          self._transformOriginLeft();
        }
        */
        ionic.requestAnimationFrame(function() { self._doDragStart(e) });
      }, this.el);

      ionic.onGesture('drag', function(e) {
        ionic.requestAnimationFrame(function() { self._doDrag(e) });
        // Indicate we want to stop parents from using this
        e.gesture.srcEvent.preventDefault();
      }, this.el);

      ionic.onGesture('dragend', function(e) {
        ionic.requestAnimationFrame(function() { self._doDragEnd(e) });
      }, this.el);
    },

    // Rotate anchored to the left of the screen
    _transformOriginLeft: function() {
      this.el.style[TRANSFORM_ORIGIN] = 'left center';
      this.rotationDirection = 1;
    },

    _transformOriginRight: function() {
      this.el.style[TRANSFORM_ORIGIN] = 'right center';
      this.rotationDirection = -1;
    },

    _doDragStart: function(e) {
      e.preventDefault();
      var width = this.el.offsetWidth;
      var point = window.innerWidth / 2 + this.rotationDirection * (width / 2)
      var distance = Math.abs(point - e.gesture.touches[0].pageX);// - window.innerWidth/2);

      this.touchDistance = distance * 10;
    },

    _doDrag: function(e) {
      e.preventDefault();

      var o = e.gesture.deltaX / -1000;

      this.rotationAngle = Math.atan(o);

      this.x = this.startX + (e.gesture.deltaX * 0.8);
      this.y = this.startY + (e.gesture.deltaY * 0.8);

      this.el.style.transform = this.el.style.webkitTransform = 'translate3d(' + this.x + 'px, ' + this.y  + 'px, 0) rotate(' + (this.rotationAngle || 0) + 'rad)';


      this.thresholdAmount = (this.x / (this.parentWidth/2));

      var self = this;
      setTimeout(function() {
        self.onPartialSwipe(self.thresholdAmount);
      });
    },
    _doDragEnd: function(e) {
      this.transitionOut(e);
    }
  });


  angular.module('ionic.contrib.ui.tinderCards', ['ionic'])

  .directive('tdCard', ['$timeout', function($timeout) {
    /**
     * A simple non-linear fade function for the text on each card
     */
    var fadeFn = function(t) {
      // Speed up time to ramp up quickly
      t = Math.min(1, t * 3);

      // This is a simple cubic bezier curve.
      // http://cubic-bezier.com/#.11,.67,.41,.99
      var c1 = 0.11,
          c2 = 0.67,
          c3 = 0.41,
          c4 = 0.99;

      return Math.pow((1 - t), 3)*c1 + 3*Math.pow((1 -  t), 2)*t*c2 + 3*(1 - t)*t*t*c3 + Math.pow(t, 3)*c4;
    };

    return {
      restrict: 'E',
      template: '<div class="td-card" ng-transclude></div>',
      require: '^tdCards',
      transclude: true,
      scope: {
        onSwipeLeft: '&',
        onSwipeRight: '&',
        onTransitionLeft: '&',
        onTransitionRight: '&',
        onTransitionOut: '&',
        onPartialSwipe: '&',
        onSnapBack: '&',
        onDestroy: '&'
      },
      compile: function(element, attr) {
        return function($scope, $element, $attr, swipeCards) {
          var el = $element[0];
          var leftText = el.querySelector('.no-text');
          var rightText = el.querySelector('.yes-text');
          
          // Force hardware acceleration for animation - better performance on first touch
          el.style.transform = el.style.webkitTransform = 'translate3d(0px, 0px, 0px)';

          // Instantiate our card view
          var swipeableCard = new SwipeableCardView({
            el: el,
            leftText: leftText,
            rightText: rightText,
            onPartialSwipe: function(amt) {
              swipeCards.partial(amt);
              var self = this;
              $timeout(function() {
                if (amt < 0) {
                  if (self.leftText) self.leftText.style.opacity = fadeFn(-amt);
                  if (self.rightText) self.rightText.style.opacity = 0;
                } else {
                  if (self.leftText) self.leftText.style.opacity = 0;
                  if (self.rightText) self.rightText.style.opacity = fadeFn(amt);
                }
                $scope.onPartialSwipe({amt: amt});
              });
            },
            onSwipeRight: function() {
              $timeout(function() {
                $scope.onSwipeRight();
              });
            },
            onSwipeLeft: function() {
              $timeout(function() {
                $scope.onSwipeLeft();
              });
            },
            onTransitionRight: function() {
              $timeout(function() {
                $scope.onTransitionRight();
              });
            },
            onTransitionLeft: function() {
              $timeout(function() {
                $scope.onTransitionLeft();
              });
            },
            onTransitionOut: function(amt) {
              if (amt < 0) {
                swipeableCard.onTransitionLeft();
              } else {
                swipeableCard.onTransitionRight();
              }
              $timeout(function() {
                $scope.onTransitionOut({amt: amt});
              });
            },
            onDestroy: function() {
              $timeout(function() {
                $scope.onDestroy();
              });
            },
            onSnapBack: function(startX, startY, startRotation) {
              var leftText = el.querySelector('.yes-text');
              var rightText = el.querySelector('.no-text');

              var animation = collide.animation({
                // 'linear|ease|ease-in|ease-out|ease-in-out|cubic-bezer(x1,y1,x2,y2)',
                // or function(t, duration),
                // or a dynamics configuration (see below)
                duration: 500,
                percent: 0,
                reverse: false
              })

              .easing({
                type: 'spring',
                frequency: 15,
                friction: 250,
                initialForce: false
              }) 

              .on('step', function(v) {
                //Have the element spring over 400px
                el.style.transform = el.style.webkitTransform = 'translate3d(' + (startX - startX*v) + 'px, ' + (startY - startY*v) + 'px, 0) rotate(' + (startRotation - startRotation*v) + 'rad)';
                if (rightText) rightText.style.opacity = 0;
                if (leftText) leftText.style.opacity = 0;
              })
              .start();

              $timeout(function() {
                $scope.onSnapBack();
              });

              /*
              animateSpringViaCss(el, 0, 0.5, 50, 700, 10, function (x) {
                return el.style.transform = el.style.webkitTransform = 'translate3d(' + x + 'px,0,0)';
              });
              */
            },
          });
          $scope.$parent.swipeCard = swipeableCard;

        }
      }
    }
  }])

  .directive('tdCards', ['$rootScope', '$timeout', function($rootScope, $timeout) {
    return {
      restrict: 'E',
      template: '<div class="td-cards" ng-transclude></div>',
      transclude: true,
      scope: {},
      controller: ['$scope', '$element', function($scope, $element) {
        var cards;
        var firstCard, secondCard, thirdCard;

        var existingCards, card;

        var i, j;

        var sortCards = function() {
          existingCards = $element[0].querySelectorAll('td-card');

          for(i = 0; i < existingCards.length; i++) {
            card = existingCards[i];
            if(!card) continue;
            if(i > 0) {
              card.style.transform = card.style.webkitTransform = 'translate3d(0, ' + (i * 4) + 'px, 0)';
            }
            card.style.zIndex = (existingCards.length - i);
          }
        };

        $timeout(function() {
          sortCards();
        });

        var bringCardUp = function(card, amt, max) {
          var position, newTop;
          position = card.style.transform || card.style.webkitTransform;
          newTop = Math.max(0, Math.min(max, max - (max * Math.abs(amt))));
          card.style.transform = card.style.webkitTransform = 'translate3d(0, ' + newTop + 'px, 0)';
        };

        this.partial = function(amt) {
          cards = $element[0].querySelectorAll('td-card');
          firstCard = cards[0];
          secondCard = cards.length > 2 && cards[1];
          thirdCard = cards.length > 3 && cards[2];

          secondCard && bringCardUp(secondCard, amt, 4);
          thirdCard && bringCardUp(thirdCard, amt, 8);
        };
      }]
    }
  }])

  .factory('TDCardDelegate', ['$rootScope', function($rootScope) {
    return {
      popCard: function($scope, isAnimated) {
        $rootScope.$emit('tdCard.pop', isAnimated);
      },
      getSwipeableCard: function($scope) {
        return $scope.swipeCard;
      }
    }
  }]);

})(window.ionic);

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/bower_components\\ionic-contrib-tinder-cards\\ionic.tdcards.js","/bower_components\\ionic-contrib-tinder-cards")
},{"VCmEsw":12,"buffer":9}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/30/2015.
 */

angular.module('activityDetails', [])

    .directive('activity',function(){
        return {
            'require':'^data',
            'restrict':'E',
            'scope':{
                onactivitydetailsinit:'&onactivitydetailsinit'
            },
            'transclude':false,
            'controller':'activityController',
            //'templateUrl':'./app/components/activityDetails/activityDetails.view.html',
            'link':function(scope,element,attrs,dataCtrl){
                scope.init(dataCtrl);
                scope.onactivitydetailsinit({scope:scope});
            }
        }

    })
    .controller('activityController',['$scope','$ionicModal',function($scope,$ionicModal){

        $scope.init= function (dataCtrl) {
            console.log('activityDetails component init',dataCtrl);
            $scope.dataCtrl=dataCtrl;

            $ionicModal.fromTemplateUrl('./app/components/activityDetails/activityDetails.view.html', function($ionicModal) {
                $scope.modal = $ionicModal;
            }, {
                // Use our scope for the scope of the modal to keep it simple
                scope: $scope,
                // The animation we want to use for the modal entrance
                animation: 'scale-in'
            });
        };

        $scope.loadactivity=function(activity){
            $scope.activity=activity;
            console.log("activity", $scope.activity);
            $scope.modal.show();
        };

    }]);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/components\\activityDetails\\activityDetails.module.js","/components\\activityDetails")
},{"VCmEsw":12,"buffer":9}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/30/2015.
 */

angular.module('dataCore', ['discoverActivities','activityDetails'])

    .directive('data',function(){
            return {
                'restrict':'E',
                'scope':{

                },
                'transclude':false,
                'controller':'dataController',
                'link':function(scope,element,attrs){
                    scope.init();
                }
            }
        })
    .controller('dataController',['$scope','$http','config','$q',function($scope,$http,config,$q){
            var self=this;
            this.items=[];

            $scope.init= function () {
                console.log('dataCore component init');

                $http.get(config.developmentDbUrl+'activity_un_search')
                    .success(function(data, status, headers, config) {
                        console.log("dataCore: success get all activities", data);
                        self.items=data.data;
                    })
                    .error(function(data, status, headers, config) {
                        console.log("error get all activities")
                    });


                //return q.promise();
            };

            //this.items = $http.get(config.developmentDbUrl+'activity_un_search')
            //    .success(function(data, status, headers, config) {
            //        console.log("dataCore: success get all activities", data);
            //        $scope.items=data;
            //    })
            //    .error(function(data, status, headers, config) {
            //        console.log("error get all activities")
            //    });

            //this.getActivity=function(id){
            //    var items = $scope.items.data;
            //    for(var i=0; i<items.length; i++)
            //    {
            //        if(items[i]._id==id)
            //        {
            //            return items[i];
            //        }
            //    }
            //}

            //this.getActivities=function() {
            //
            //    console.log("config", config.developmentDbUrl);
            //
            //    return $http.get(config.developmentDbUrl+'activity_un_search')
            //        .success(function(data, status, headers, config) {
            //            //console.log("dataCore: success get all activities", data);
            //        })
            //        .error(function(data, status, headers, config) {
            //            //console.log("error get all activities")
            //        });
            //
            //    //return [{activity: 'activity1'}, {activity: 'activity2'}];
            //}

        }]);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/components\\dataCore\\dataCore.module.js","/components\\dataCore")
},{"VCmEsw":12,"buffer":9}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/30/2015.
 */

angular.module('discoverActivities', ['ionic.contrib.ui.tinderCards'])

    .directive('discover',function(){
        return {
            'require':'^data',
            'restrict':'E',
            'scope':{
                ondiscoveractivitiesinit:'&ondiscoveractivitiesinit',
                onactivitydetail:'&onactivitydetail'
            },
            'transclude':false,
            'controller':'discoverController',
            'templateUrl':'./app/components/discoverActivities/discoverActivities.view.html',
            'link':function(scope,element,attrs,dataCtrl){

                scope.init(dataCtrl);

                //dataCtrl.items.then(function(data){
                //    scope.init(data.data.data);
                //});

                //dataCtrl.getActivities()
                //    .success(function(response){
                //        console.log("discoverActivities: success get all activities", response);
                //        scope.init(response.data);
                //    })
                //    .error(function(response){
                //        console.log("discoverActivities: error get all activities", response);
                //    });

                scope.ondiscoveractivitiesinit({scope:scope});
            }
        }

    })
    .controller('discoverController',['$scope',function($scope){

        $scope.init= function (dataCore) {
            console.log('discoverActivities component init',dataCore);
            $scope.dataCore=dataCore;
            //$scope.activities=activities;
            //$scope.activities.splice(5, 38);
        };

        $scope.cardSwipedLeft= function(index) {
            console.log("card "+index+" swiped left ");
        };

        $scope.cardSwipedRight= function(index,id) {
            console.log("card "+index+" swiped right ");
        };

        $scope.cardDestroyed = function(index) {
            console.log("index",index);
            console.log("before slice", $scope.dataCore.items);
            $scope.dataCore.items.slice(index, 1);
            console.log("after slice", $scope.dataCore.items);
        };

        $scope.openActivity=function(activity){
            $scope.onactivitydetail({activity:activity});
        };

    }]);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/components\\discoverActivities\\discoverActivities.module.js","/components\\discoverActivities")
},{"VCmEsw":12,"buffer":9}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/30/2015.
 */

angular.module('main', ['dataCore'])

    .directive('main',function(){
        return {
            'restrict':'E',
            'scope':{

            },
            'transclude':false,
            'controller':'mainController',
            'templateUrl':'./app/components/main/main.view.html',
            'link':function(scope,element,attrs){
                scope.init();
            }
        }
    })
    .controller('mainController',['$scope',function($scope){

        $scope.showDetails=false;

        $scope.init= function () {
            console.log('main component init');
        };

        $scope.ondiscoveractivitiesinit=function(discoverActivities){
            console.log("discoverActivities init in MAIN");
            $scope.discoverActivities=discoverActivities;
        }

        $scope.onactivitydetailsinit=function(activityDetails){
            console.log("activityDetails init in MAIN");
            $scope.activityDetails=activityDetails;
        }

        $scope.onactivitydetail=function(activity){
            $scope.showDetails=true;
            $scope.activityDetails.loadactivity(activity);
        }

    }]);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/components\\main\\main.module.js","/components\\main")
},{"VCmEsw":12,"buffer":9}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/30/2015.
 */

require('./shared/config/config.module.js');
require('./components/activityDetails/activityDetails.module.js');
require('./components/discoverActivities/discoverActivities.module.js');
require('./components/dataCore/dataCore.module.js');
require('./components/main/main.module.js');

global.collide=require('./bower_components/collide/collide.js');
require('./bower_components/ionic-contrib-tinder-cards/ionic.tdcards.js');


var app=angular.module('starter', ['ionic','config','dataCore','main']);
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_4b582f87.js","/")
},{"./bower_components/collide/collide.js":1,"./bower_components/ionic-contrib-tinder-cards/ionic.tdcards.js":2,"./components/activityDetails/activityDetails.module.js":3,"./components/dataCore/dataCore.module.js":4,"./components/discoverActivities/discoverActivities.module.js":5,"./components/main/main.module.js":6,"./shared/config/config.module.js":8,"VCmEsw":12,"buffer":9}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * Created by oleg on 6/29/2015.
 */
    angular.module('config', [])
    .constant('config', {
        push: {
            ios: {
                badge: true,
                sound: true,
                alert: true
            },
            android: {
                "senderID": "59336322951"
            }
        },
        senderID:'59336322951',
        fbAppId:'466269356751173',
        productionDbUrl:'https://salty-peak-2515.herokuapp.com/',
        developmentDbUrl:'https://floating-depths-2240.herokuapp.com/'
    });
}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/shared\\config\\config.module.js","/shared\\config")
},{"VCmEsw":12,"buffer":9}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\index.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer")
},{"VCmEsw":12,"base64-js":10,"buffer":9,"ieee754":11}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib\\b64.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib")
},{"VCmEsw":12,"buffer":9}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754\\index.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754")
},{"VCmEsw":12,"buffer":9}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("VCmEsw"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\process\\browser.js","/..\\node_modules\\gulp-browserify\\node_modules\\browserify\\node_modules\\process")
},{"VCmEsw":12,"buffer":9}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcb2xlZ1xcRGV2XFxEaXJlY3RvcnlTdHJ1Y3R1cmVBcHBcXG5vZGVfbW9kdWxlc1xcZ3VscC1icm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9hcHAvYm93ZXJfY29tcG9uZW50cy9jb2xsaWRlL2NvbGxpZGUuanMiLCJDOi9Vc2Vycy9vbGVnL0Rldi9EaXJlY3RvcnlTdHJ1Y3R1cmVBcHAvYXBwL2Jvd2VyX2NvbXBvbmVudHMvaW9uaWMtY29udHJpYi10aW5kZXItY2FyZHMvaW9uaWMudGRjYXJkcy5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9hcHAvY29tcG9uZW50cy9hY3Rpdml0eURldGFpbHMvYWN0aXZpdHlEZXRhaWxzLm1vZHVsZS5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9hcHAvY29tcG9uZW50cy9kYXRhQ29yZS9kYXRhQ29yZS5tb2R1bGUuanMiLCJDOi9Vc2Vycy9vbGVnL0Rldi9EaXJlY3RvcnlTdHJ1Y3R1cmVBcHAvYXBwL2NvbXBvbmVudHMvZGlzY292ZXJBY3Rpdml0aWVzL2Rpc2NvdmVyQWN0aXZpdGllcy5tb2R1bGUuanMiLCJDOi9Vc2Vycy9vbGVnL0Rldi9EaXJlY3RvcnlTdHJ1Y3R1cmVBcHAvYXBwL2NvbXBvbmVudHMvbWFpbi9tYWluLm1vZHVsZS5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9hcHAvZmFrZV80YjU4MmY4Ny5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9hcHAvc2hhcmVkL2NvbmZpZy9jb25maWcubW9kdWxlLmpzIiwiQzovVXNlcnMvb2xlZy9EZXYvRGlyZWN0b3J5U3RydWN0dXJlQXBwL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiQzovVXNlcnMvb2xlZy9EZXYvRGlyZWN0b3J5U3RydWN0dXJlQXBwL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIkM6L1VzZXJzL29sZWcvRGV2L0RpcmVjdG9yeVN0cnVjdHVyZUFwcC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLmNvbGxpZGU9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuM1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLypcbiovXG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwicWhESVJUXCIpKVxufSx7XCJxaERJUlRcIjoxM31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIG5vdyA9IF9kZXJlcV8oJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IHdpbmRvd1xuICAsIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxuICAsIHN1ZmZpeCA9ICdBbmltYXRpb25GcmFtZSdcbiAgLCByYWYgPSBnbG9iYWxbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IGdsb2JhbFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgZ2xvYmFsWydjYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cblxuZm9yKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICFyYWY7IGkrKykge1xuICByYWYgPSBnbG9iYWxbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gZ2xvYmFsW3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IGdsb2JhbFt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxufVxuXG4vLyBTb21lIHZlcnNpb25zIG9mIEZGIGhhdmUgckFGIGJ1dCBub3QgY0FGXG5pZighcmFmIHx8ICFjYWYpIHtcbiAgdmFyIGxhc3QgPSAwXG4gICAgLCBpZCA9IDBcbiAgICAsIHF1ZXVlID0gW11cbiAgICAsIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gNjBcblxuICByYWYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIF9ub3cgPSBub3coKVxuICAgICAgICAsIG5leHQgPSBNYXRoLm1heCgwLCBmcmFtZUR1cmF0aW9uIC0gKF9ub3cgLSBsYXN0KSlcbiAgICAgIGxhc3QgPSBuZXh0ICsgX25vd1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNwID0gcXVldWUuc2xpY2UoMClcbiAgICAgICAgLy8gQ2xlYXIgcXVldWUgaGVyZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGNhbGxiYWNrcyBmcm9tIGFwcGVuZGluZyBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgZnJhbWUncyBxdWV1ZVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY3BbaV0uY2FsbGJhY2sobGFzdClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG5leHQpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gV3JhcCBpbiBhIG5ldyBmdW5jdGlvbiB0byBwcmV2ZW50XG4gIC8vIGBjYW5jZWxgIHBvdGVudGlhbGx5IGJlaW5nIGFzc2lnbmVkXG4gIC8vIHRvIHRoZSBuYXRpdmUgckFGIGZ1bmN0aW9uXG4gIHJldHVybiByYWYuYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KGdsb2JhbCwgYXJndW1lbnRzKVxufVxuXG59LHtcInBlcmZvcm1hbmNlLW5vd1wiOjN9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzPV9kZXJlcV8oMSlcbn0se1wicWhESVJUXCI6MTN9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLy8gSW50ZXJwb2xhdGlvbiBkaXNhYmxlZCBmb3Igbm93XG4vLyB2YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuL2NvcmUvaW50ZXJwb2xhdGUnKTtcbi8vIHZhciBjc3NGZWF0dXJlID0gcmVxdWlyZSgnZmVhdHVyZS9jc3MnKTtcblxudmFyIHRpbWVsaW5lID0gX2RlcmVxXygnLi9jb3JlL3RpbWVsaW5lJyk7XG52YXIgZHluYW1pY3MgPSBfZGVyZXFfKCcuL2NvcmUvZHluYW1pY3MnKTtcbnZhciBlYXNpbmdGdW5jdGlvbnMgPSBfZGVyZXFfKCcuL2NvcmUvZWFzaW5nLWZ1bmN0aW9ucycpO1xuXG52YXIgdWlkID0gX2RlcmVxXygnLi91dGlsL3VpZCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJy4vdXRpbC9zaW1wbGUtZW1pdHRlcicpO1xuXG5mdW5jdGlvbiBjbGFtcChtaW4sIG4sIG1heCkgeyByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihuLCBtYXgpKTsgfVxuXG52YXIgVkVMT0NJVFlfTUlOID0gMC4wMDc1O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcblxuZnVuY3Rpb24gQW5pbWF0aW9uKG9wdHMpIHtcbiAgLy9pZiBgbmV3YCBrZXl3b3JkIGlzbid0IHByb3ZpZGVkLCBkbyBpdCBmb3IgdXNlclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKG9wdHMpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcblxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIC8vUHJpdmF0ZSBzdGF0ZSBnb2VzIGluIHRoaXMuX1xuICB0aGlzLl8gPSB7XG4gICAgaWQ6IHVpZCgpLFxuICAgIHBlcmNlbnQ6IDAsXG4gICAgZHVyYXRpb246IDUwMCxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBkaXN0YW5jZTogMTAwLFxuICAgIGRlY2VsZXJhdGlvbjogMC45OThcbiAgfTtcblxuICB2YXIgZW1pdHRlciA9IHRoaXMuXy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB0aGlzLl8ub25EZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgZW1pdHRlci5lbWl0KCdkZXN0cm95Jyk7XG4gIH07XG4gIHRoaXMuXy5vblN0b3AgPSBmdW5jdGlvbih3YXNDb21wbGV0ZWQpIHtcbiAgICBlbWl0dGVyLmVtaXQoJ3N0b3AnLCB3YXNDb21wbGV0ZWQpO1xuICAgIHdhc0NvbXBsZXRlZCAmJiBlbWl0dGVyLmVtaXQoJ2NvbXBsZXRlJyk7XG4gIH07XG4gIHRoaXMuXy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgZW1pdHRlci5lbWl0KCdzdGFydCcpO1xuICB9O1xuXG4gIHZhciBwcmVjaXNpb24gPSAxMDAwMDtcbiAgdGhpcy5fLm9uU3RlcCA9IGZ1bmN0aW9uKHYpIHtcbiAgICBlbWl0dGVyLmVtaXQoJ3N0ZXAnLCBNYXRoLnJvdW5kKHYgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgfTtcblxuICBvcHRzLmR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb24ob3B0cy5kdXJhdGlvbik7XG4gIG9wdHMucGVyY2VudCAmJiB0aGlzLnBlcmNlbnQob3B0cy5wZXJjZW50KTtcbiAgb3B0cy5lYXNpbmcgJiYgdGhpcy5lYXNpbmcob3B0cy5lYXNpbmcpO1xuICBvcHRzLnJldmVyc2UgJiYgdGhpcy5yZXZlcnNlKG9wdHMucmV2ZXJzZSk7XG4gIG9wdHMuZGlzdGFuY2UgJiYgdGhpcy5kaXN0YW5jZShvcHRzLmRpc3RhbmNlKTtcbiBcbiAgLy9QdXQgdGhpcyBoZXJlIHNvIHdlIGRvbid0IGhhdmUgdG8gY2FsbCBfdGljayBpbiB0aGUgY29udGV4dCBvZiBvdXIgb2JqZWN0LlxuICAvL0F2b2lkcyBoYXZpbmcgdG8gdXNlIC5iaW5kKCkgb3IgLmNhbGwoKSBldmVyeSBmcmFtZS5cbiAgc2VsZi5fdGljayA9IGZ1bmN0aW9uKGRlbHRhVCkge1xuICAgIHZhciBzdGF0ZSA9IHNlbGYuXztcbiAgICBcbiAgICBzdGF0ZS5vblN0ZXAoYW5pbVN0ZXBWYWx1ZShzZWxmLCBzdGF0ZS5wZXJjZW50KSk7XG5cbiAgICBpZiAoTWF0aC5hYnMoc3RhdGUudmVsb2NpdHkpIDwgVkVMT0NJVFlfTUlOKSB7XG4gICAgICBzdGF0ZS52ZWxvY2l0eSA9IDA7XG4gICAgICByZXR1cm4gc2VsZi5zdG9wKCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5wZXJjZW50ID09PSBhbmltRW5kUGVyY2VudChzZWxmKSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3RvcCgpO1xuICAgIH1cblxuICAgIC8vRmlyc3QgdGljaywgZG9uJ3QgdXAgdGhlIHBlcmNlbnRcbiAgICBpZiAoIWRlbHRhVCkge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAoc3RhdGUudmVsb2NpdHkpIHtcbiAgICAgIHZhciB2ZWxvY2l0eSA9IGRlY2F5VmVsb2NpdHkoc3RhdGUudmVsb2NpdHksIGRlbHRhVCwgc3RhdGUuZGVjZWxlcmF0aW9uKTtcbiAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBzdGF0ZS5wZXJjZW50ICogc3RhdGUuZGlzdGFuY2U7XG4gICAgICBzdGF0ZS5wZXJjZW50ID0gKGN1cnJlbnREaXN0YW5jZSAtIHZlbG9jaXR5KSAvIHN0YXRlLmRpc3RhbmNlO1xuXG4gICAgICBpZiAoc3RhdGUucGVyY2VudCA+IDEgfHwgc3RhdGUucGVyY2VudCA8IDApIHtcbiAgICAgICAgc3RhdGUucGVyY2VudCA9IGNsYW1wKDAsIHN0YXRlLnBlcmNlbnQsIDEpO1xuICAgICAgICBzdGF0ZS52ZWxvY2l0eSA9IDA7XG4gICAgICB9XG4gICAgICBzdGF0ZS52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUucmV2ZXJzZSkge1xuICAgICAgICBzdGF0ZS5wZXJjZW50ID0gc3RhdGUucGVyY2VudCAtIChkZWx0YVQgLyBzdGF0ZS5kdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wZXJjZW50ID0gc3RhdGUucGVyY2VudCArIChkZWx0YVQgLyBzdGF0ZS5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucGVyY2VudCA9IGNsYW1wKDAsIHN0YXRlLnBlcmNlbnQsIDEpO1xuICB9O1xufVxuXG5BbmltYXRpb24ucHJvdG90eXBlID0ge1xuICByZXZlcnNlOiBmdW5jdGlvbihyZXZlcnNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuXy5yZXZlcnNlID0gISFyZXZlcnNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl8ucmV2ZXJzZTtcbiAgfSxcblxuICBlYXNpbmc6IGZ1bmN0aW9uKGVhc2luZykge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGVhc2luZztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fLmVhc2luZyA9IGZpZ3VyZU91dEVhc2luZyhlYXNpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl8uZWFzaW5nO1xuICB9LFxuXG4gIHBlcmNlbnQ6IGZ1bmN0aW9uKHBlcmNlbnQsIGltbWVkaWF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwZXJjZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl8ucGVyY2VudCA9IGNsYW1wKDAsIHBlcmNlbnQsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICB0aGlzLl90aWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZWxpbmUudGlja0FjdGlvbih0aGlzLl8uaWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fdGljaygpO1xuICAgICAgICAgICAgdGltZWxpbmUudW50aWNrQWN0aW9uKHNlbGYuXy5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fLnBlcmNlbnQ7XG4gIH0sXG5cbiAgZGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT09ICdudW1iZXInICYmIGRpc3RhbmNlID4gMCkge1xuICAgICAgICB0aGlzLl8uZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fLmRpc3RhbmNlO1xuICB9LFxuXG4gIGRlY2VsZXJhdGlvbjogZnVuY3Rpb24oZGVjZWxlcmF0aW9uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVjZWxlcmF0aW9uID09PSAnbnVtYmVyJyAmJiBkZWNlbGVyYXRpb24gPiAwICYmIGRlY2VsZXJhdGlvbiA8IDEpIHtcbiAgICAgICAgdGhpcy5fLmRlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fLmRlY2VsZXJhdGlvbjtcbiAgfSxcblxuICBkdXJhdGlvbjogZnVuY3Rpb24oZHVyYXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgZHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHRoaXMuXy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl8uZHVyYXRpb247XG4gIH0sXG5cbiAgaXNSdW5uaW5nOiBmdW5jdGlvbigpIHsgXG4gICAgcmV0dXJuICEhdGhpcy5fLmlzUnVubmluZzsgXG4gIH0sXG5cbiAgcHJvbWlzZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB0aGVuOiBmdW5jdGlvbihjYikge1xuICAgICAgICBzZWxmLm9uY2UoJ3N0b3AnLCBjYik7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBvbjogZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuXy5lbWl0dGVyLm9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fLmVtaXR0ZXIub25jZShldmVudFR5cGUsIGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fLmVtaXR0ZXIub2ZmKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuXy5vbkRlc3Ryb3koKTtcbiAgICB0aGlzLm9mZigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5fLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRpbWVsaW5lLnVudGlja0FjdGlvbih0aGlzLl8uaWQpO1xuXG4gICAgdGhpcy5fLm9uU3RvcChhbmltSXNDb21wbGV0ZSh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVzdGFydDogZnVuY3Rpb24oaW1tZWRpYXRlKSB7XG4gICAgaWYgKHRoaXMuXy5pc1J1bm5pbmcpIHJldHVybjtcblxuICAgIHRoaXMuXy5wZXJjZW50ID0gYW5pbVN0YXJ0UGVyY2VudCh0aGlzKTtcblxuICAgIHJldHVybiB0aGlzLnN0YXJ0KCEhaW1tZWRpYXRlKTtcbiAgfSxcblxuICBzdGFydDogZnVuY3Rpb24oaW1tZWRpYXRlKSB7XG4gICAgcmV0dXJuIGFuaW1CZWdpbih0aGlzLCBpbW1lZGlhdGUpO1xuICB9LFxuXG4gIHZlbG9jaXR5OiBmdW5jdGlvbih2ZWxvY2l0eSwgaW1tZWRpYXRlKSB7XG4gICAgdGhpcy5fLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgcmV0dXJuIGFuaW1CZWdpbih0aGlzLCBpbW1lZGlhdGUpO1xuICB9LFxufTtcblxuZnVuY3Rpb24gYW5pbUJlZ2luKGFuaW1hdGlvbiwgaW1tZWRpYXRlKSB7XG4gIGlmIChpbW1lZGlhdGUpIHtcbiAgICBhbmltYXRpb24uX3RpY2soKTtcbiAgfVxuXG4gIGFuaW1hdGlvbi5fLmlzUnVubmluZyA9IHRydWU7XG4gIHRpbWVsaW5lLnRpY2tBY3Rpb24oYW5pbWF0aW9uLl8uaWQsIGFuaW1hdGlvbi5fdGljayk7XG5cbiAgYW5pbWF0aW9uLl8ub25TdGFydCgpO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufVxuZnVuY3Rpb24gYW5pbUlzQ29tcGxldGUoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uLl8uaXNSdW5uaW5nICYmIFxuICAgIGFuaW1hdGlvbi5fLnBlcmNlbnQgPT09IGFuaW1FbmRQZXJjZW50KGFuaW1hdGlvbik7XG59XG5mdW5jdGlvbiBhbmltRW5kUGVyY2VudChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fLnJldmVyc2UgPyAwIDogMTtcbn1cbmZ1bmN0aW9uIGFuaW1TdGFydFBlcmNlbnQoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uXy5yZXZlcnNlID8gMSA6IDA7XG59XG5mdW5jdGlvbiBhbmltU3RlcFZhbHVlKGFuaW1hdGlvbiwgdmFsdWUpIHtcbiAgaWYgKGFuaW1hdGlvbi5fLmVhc2luZykge1xuICAgIHJldHVybiBhbmltYXRpb24uXy5lYXNpbmcodmFsdWUsIGFuaW1hdGlvbi5fLmR1cmF0aW9uKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRlY2F5VmVsb2NpdHkodmVsb2NpdHksIGR0LCBkZWNlbGVyYXRpb24pIHtcbiAgdmFyIGt2ID0gTWF0aC5wb3coZGVjZWxlcmF0aW9uLCBkdCk7XG4gIHJldHVybiB2ZWxvY2l0eSAqIGt2O1xufVxuXG5mdW5jdGlvbiBmaWd1cmVPdXRFYXNpbmcoZWFzaW5nKSB7XG4gIGlmICh0eXBlb2YgZWFzaW5nID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IHR5cGVvZiBlYXNpbmcudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIGVhc2luZy50eXBlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgaWYgKCFkeW5hbWljc1tkeW5hbWljVHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgZWFzaW5nIGR5bmFtaWNzIG9iamVjdCB0eXBlIFwiJyArIGVhc2luZy50eXBlICsgJ1wiLiAnICtcbiAgICAgICAgJ0F2YWlsYWJsZSBkeW5hbWljcyB0eXBlczogJyArIE9iamVjdC5rZXlzKGR5bmFtaWNzKS5qb2luKCcsICcpICsgJy4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY3NbZHluYW1pY1R5cGVdKGVhc2luZyk7XG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgZWFzaW5nID09PSAnc3RyaW5nJykge1xuICAgIGVhc2luZyA9IGVhc2luZy50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICBcbiAgICBpZiAoZWFzaW5nLmluZGV4T2YoJ2N1YmljLWJlemllcignKSA9PT0gMCkge1xuICAgICAgdmFyIHBhcnRzID0gZWFzaW5nXG4gICAgICAgIC5yZXBsYWNlKCdjdWJpYy1iZXppZXIoJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCcpJywgJycpXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiB2LnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4gZWFzaW5nRnVuY3Rpb25zWydjdWJpYy1iZXppZXInXShwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdLCBwYXJ0c1szXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmbiA9IGVhc2luZ0Z1bmN0aW9uc1tlYXNpbmddO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgZWFzaW5nIGZ1bmN0aW9uIFwiJyArIGVhc2luZyArICdcIi4gJyArXG4gICAgICAgICAgJ0F2YWlsYWJsZSBlYXNpbmcgZnVuY3Rpb25zOiAnICsgT2JqZWN0LmtleXMoZWFzaW5nRnVuY3Rpb25zKS5qb2luKCcsICcpICsgJy4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWFzaW5nRnVuY3Rpb25zW2Vhc2luZ10oKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlYXNpbmc7XG4gIH1cbn1cblxuLy8gLypcbi8vICAqIFR3ZWVuaW5nIGhlbHBlcnNcbi8vICAqL1xuLy8gZnVuY3Rpb24gc3luY1N0eWxlcyhzdGFydGluZ1N0eWxlcywgZW5kaW5nU3R5bGVzLCBjb21wdXRlZFN0eWxlKSB7XG4vLyAgIHZhciBwcm9wZXJ0eTtcbi8vICAgZm9yIChwcm9wZXJ0eSBpbiBzdGFydGluZ1N0eWxlcykge1xuLy8gICAgIGlmICghZW5kaW5nU3R5bGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuLy8gICAgICAgZGVsZXRlIHN0YXJ0aW5nU3R5bGVzW3Byb3BlcnR5XTtcbi8vICAgICB9XG4vLyAgIH1cbi8vICAgZm9yIChwcm9wZXJ0eSBpbiBlbmRpbmdTdHlsZXMpIHtcbi8vICAgICBpZiAoIXN0YXJ0aW5nU3R5bGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuLy8gICAgICAgc3RhcnRpbmdTdHlsZXNbcHJvcGVydHldID0gY29tcHV0ZWRTdHlsZVt2ZW5kb3JpemVQcm9wZXJ0eU5hbWUocHJvcGVydHkpXTtcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLy8gZnVuY3Rpb24gbWFrZVByb3BlcnR5SW50ZXJwb2xhdG9ycyhzdGFydGluZ1N0eWxlcywgZW5kaW5nU3R5bGVzKSB7XG4vLyAgIHZhciBpbnRlcnBvbGF0b3JzID0ge307XG4vLyAgIHZhciBwcm9wZXJ0eTtcbi8vICAgZm9yIChwcm9wZXJ0eSBpbiBzdGFydGluZ1N0eWxlcykge1xuLy8gICAgIGludGVycG9sYXRvcnNbdmVuZG9yaXplUHJvcGVydHlOYW1lKHByb3BlcnR5KV0gPSBpbnRlcnBvbGF0ZS5wcm9wZXJ0eUludGVycG9sYXRvcihcbi8vICAgICAgIHByb3BlcnR5LCBzdGFydGluZ1N0eWxlc1twcm9wZXJ0eV0sIGVuZGluZ1N0eWxlc1twcm9wZXJ0eV1cbi8vICAgICApO1xuLy8gICB9XG4vLyAgIHJldHVybiBpbnRlcnBvbGF0b3JzO1xuLy8gfVxuXG4vLyB2YXIgdHJhbnNmb3JtUHJvcGVydHk7XG4vLyBmdW5jdGlvbiB2ZW5kb3JpemVQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbi8vICAgaWYgKHByb3BlcnR5ID09PSAndHJhbnNmb3JtJykge1xuLy8gICAgIC8vU2V0IHRyYW5zZm9ybVByb3BlcnR5IGxhemlseSwgdG8gYmUgc3VyZSBET00gaGFzIGxvYWRlZCBhbHJlYWR5IHdoZW4gdXNpbmcgaXRcbi8vICAgICByZXR1cm4gdHJhbnNmb3JtUHJvcGVydHkgfHwgXG4vLyAgICAgICAodHJhbnNmb3JtUHJvcGVydHkgPSBjc3NGZWF0dXJlKCd0cmFuc2Zvcm0nKS5wcm9wZXJ0eSk7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgcmV0dXJuIHByb3BlcnR5O1xuLy8gICB9XG4vLyB9XG5cbn0se1wiLi9jb3JlL2R5bmFtaWNzXCI6NixcIi4vY29yZS9lYXNpbmctZnVuY3Rpb25zXCI6NyxcIi4vY29yZS90aW1lbGluZVwiOjgsXCIuL3V0aWwvc2ltcGxlLWVtaXR0ZXJcIjoxMSxcIi4vdXRpbC91aWRcIjoxMn1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdHJhbnNpdGlvbnMvI3RyYW5zaXRpb24tZWFzaW5nLWZ1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cyA9ICB7XG4gIC8qXG4gICAqIEBwYXJhbSB4IHtudW1iZXJ9IHRoZSB2YWx1ZSBvZiB4IGFsb25nIHRoZSBiZXppZXIgY3VydmUsIDAuMCA8PSB4IDw9IDEuMFxuICAgKiBAcGFyYW0gZHVyYXRpb24ge251bWJlcn0gdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHkgdmFsdWUgYWxvbmcgdGhlIGJlemllciBjdXJ2ZVxuICAgKi9cbiAgbGluZWFyOiB1bml0QmV6aWVyKDAuMCwgMC4wLCAxLjAsIDEuMCksXG5cbiAgLypcbiAgICogQHBhcmFtIHgge251bWJlcn0gdGhlIHZhbHVlIG9mIHggYWxvbmcgdGhlIGJlemllciBjdXJ2ZSwgMC4wIDw9IHggPD0gMS4wXG4gICAqIEBwYXJhbSBkdXJhdGlvbiB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgeSB2YWx1ZSBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlXG4gICAqL1xuICBlYXNlOiB1bml0QmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMS4wKSxcblxuICAvKlxuICAgKiBAcGFyYW0geCB7bnVtYmVyfSB0aGUgdmFsdWUgb2YgeCBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlLCAwLjAgPD0geCA8PSAxLjBcbiAgICogQHBhcmFtIGR1cmF0aW9uIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB5IHZhbHVlIGFsb25nIHRoZSBiZXppZXIgY3VydmVcbiAgICovXG4gIGVhc2VJbjogdW5pdEJlemllcigwLjQyLCAwLCAxLjAsIDEuMCksXG5cbiAgLypcbiAgICogQHBhcmFtIHgge251bWJlcn0gdGhlIHZhbHVlIG9mIHggYWxvbmcgdGhlIGJlemllciBjdXJ2ZSwgMC4wIDw9IHggPD0gMS4wXG4gICAqIEBwYXJhbSBkdXJhdGlvbiB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgeSB2YWx1ZSBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlXG4gICAqL1xuICBlYXNlT3V0OiB1bml0QmV6aWVyKDAsIDAsIDAuNTgsIDEuMCksXG5cbiAgLypcbiAgICogQHBhcmFtIHgge251bWJlcn0gdGhlIHZhbHVlIG9mIHggYWxvbmcgdGhlIGJlemllciBjdXJ2ZSwgMC4wIDw9IHggPD0gMS4wXG4gICAqIEBwYXJhbSBkdXJhdGlvbiB7bnVtYmVyfSB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgeSB2YWx1ZSBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlXG4gICAqL1xuICBlYXNlSW5PdXQ6IHVuaXRCZXppZXIoMC40MiwgMCwgMC41OCwgMS4wKSxcblxuICAvKlxuICAgKiBAcGFyYW0gcDF4IHtudW1iZXJ9IFggY29tcG9uZW50IG9mIGNvbnRyb2wgcG9pbnQgMVxuICAgKiBAcGFyYW0gcDF5IHtudW1iZXJ9IFkgY29tcG9uZW50IG9mIGNvbnRyb2wgcG9pbnQgMVxuICAgKiBAcGFyYW0gcDJ4IHtudW1iZXJ9IFggY29tcG9uZW50IG9mIGNvbnRyb2wgcG9pbnQgMlxuICAgKiBAcGFyYW0gcDJ5IHtudW1iZXJ9IFkgY29tcG9uZW50IG9mIGNvbnRyb2wgcG9pbnQgMlxuICAgKiBAcGFyYW0geCB7bnVtYmVyfSB0aGUgdmFsdWUgb2YgeCBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlLCAwLjAgPD0geCA8PSAxLjBcbiAgICogQHBhcmFtIGR1cmF0aW9uIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB5IHZhbHVlIGFsb25nIHRoZSBiZXppZXIgY3VydmVcbiAgICovXG4gIGN1YmljQmV6aWVyOiBmdW5jdGlvbihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICByZXR1cm4gdW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBCMSh0KSB7IHJldHVybiB0KnQqdDsgfVxuZnVuY3Rpb24gQjIodCkgeyByZXR1cm4gMyp0KnQqKDEtdCk7IH1cbmZ1bmN0aW9uIEIzKHQpIHsgcmV0dXJuIDMqdCooMS10KSooMS10KTsgfVxuZnVuY3Rpb24gQjQodCkgeyByZXR1cm4gKDEtdCkqKDEtdCkqKDEtdCk7IH1cblxuLypcbiAqIEphdmFTY3JpcHQgcG9ydCBvZiBXZWJraXQgaW1wbGVtZW50YXRpb24gb2YgQ1NTIGN1YmljLWJlemllcihwMXgucDF5LHAyeCxwMnkpIGJ5IGh0dHA6Ly9tY2subWVcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG4vKlxuICogRHVyYXRpb24gdmFsdWUgdG8gdXNlIHdoZW4gb25lIGlzIG5vdCBzcGVjaWZpZWQgKDQwMG1zIGlzIGEgY29tbW9uIHZhbHVlKS5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIERFRkFVTFRfRFVSQVRJT04gPSA0MDA7Ly9tc1xuXG4vKlxuICogVGhlIGVwc2lsb24gdmFsdWUgd2UgcGFzcyB0byBVbml0QmV6aWVyOjpzb2x2ZSBnaXZlbiB0aGF0IHRoZSBhbmltYXRpb24gaXMgZ29pbmcgdG8gcnVuIG92ZXIgfGR1cnwgc2Vjb25kcy5cbiAqIFRoZSBsb25nZXIgdGhlIGFuaW1hdGlvbiwgdGhlIG1vcmUgcHJlY2lzaW9uIHdlIG5lZWQgaW4gdGhlIGVhc2luZyBmdW5jdGlvbiByZXN1bHQgdG8gYXZvaWQgdWdseSBkaXNjb250aW51aXRpZXMuXG4gKiBodHRwOi8vc3ZuLndlYmtpdC5vcmcvcmVwb3NpdG9yeS93ZWJraXQvdHJ1bmsvU291cmNlL1dlYkNvcmUvcGFnZS9hbmltYXRpb24vQW5pbWF0aW9uQmFzZS5jcHBcbiAqL1xuZnVuY3Rpb24gc29sdmVFcHNpbG9uKGR1cmF0aW9uKSB7XG4gIHJldHVybiAxLjAgLyAoMjAwLjAgKiBkdXJhdGlvbik7XG59XG5cbi8qXG4gKiBEZWZpbmVzIGEgY3ViaWMtYmV6aWVyIGN1cnZlIGdpdmVuIHRoZSBtaWRkbGUgdHdvIGNvbnRyb2wgcG9pbnRzLlxuICogTk9URTogZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlIGltcGxpY2l0bHkgKDAsMCkgYW5kICgxLDEpLlxuICogQHBhcmFtIHAxeCB7bnVtYmVyfSBYIGNvbXBvbmVudCBvZiBjb250cm9sIHBvaW50IDFcbiAqIEBwYXJhbSBwMXkge251bWJlcn0gWSBjb21wb25lbnQgb2YgY29udHJvbCBwb2ludCAxXG4gKiBAcGFyYW0gcDJ4IHtudW1iZXJ9IFggY29tcG9uZW50IG9mIGNvbnRyb2wgcG9pbnQgMlxuICogQHBhcmFtIHAyeSB7bnVtYmVyfSBZIGNvbXBvbmVudCBvZiBjb250cm9sIHBvaW50IDJcbiAqL1xuZnVuY3Rpb24gdW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcblxuICAvLyBwcml2YXRlIG1lbWJlcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuXG4gIC8qXG4gICAqIFggY29tcG9uZW50IG9mIEJlemllciBjb2VmZmljaWVudCBDXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdmFyIGN4ID0gMy4wICogcDF4O1xuXG4gIC8qXG4gICAqIFggY29tcG9uZW50IG9mIEJlemllciBjb2VmZmljaWVudCBCXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdmFyIGJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSBjeDtcblxuICAvKlxuICAgKiBYIGNvbXBvbmVudCBvZiBCZXppZXIgY29lZmZpY2llbnQgQVxuICAgKiBAY29uc3RcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHZhciBheCA9IDEuMCAtIGN4IC1ieDtcblxuICAvKlxuICAgKiBZIGNvbXBvbmVudCBvZiBCZXppZXIgY29lZmZpY2llbnQgQ1xuICAgKiBAY29uc3RcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHZhciBjeSA9IDMuMCAqIHAxeTtcblxuICAvKlxuICAgKiBZIGNvbXBvbmVudCBvZiBCZXppZXIgY29lZmZpY2llbnQgQlxuICAgKiBAY29uc3RcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHZhciBieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gY3k7XG5cbiAgLypcbiAgICogWSBjb21wb25lbnQgb2YgQmV6aWVyIGNvZWZmaWNpZW50IEFcbiAgICogQGNvbnN0XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB2YXIgYXkgPSAxLjAgLSBjeSAtIGJ5O1xuXG4gIC8qXG4gICAqIEBwYXJhbSB0IHtudW1iZXJ9IHBhcmFtZXRyaWMgZWFzaW5nIHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHZhciBzYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQ7XG4gIH07XG5cbiAgLypcbiAgICogQHBhcmFtIHQge251bWJlcn0gcGFyYW1ldHJpYyBlYXNpbmcgdmFsdWVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdmFyIHNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdDtcbiAgfTtcblxuICAvKlxuICAgKiBAcGFyYW0gdCB7bnVtYmVyfSBwYXJhbWV0cmljIGVhc2luZyB2YWx1ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YXIgc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKDMuMCAqIGF4ICogdCArIDIuMCAqIGJ4KSAqIHQgKyBjeDtcbiAgfTtcblxuICAvKlxuICAgKiBHaXZlbiBhbiB4IHZhbHVlLCBmaW5kIGEgcGFyYW1ldHJpYyB2YWx1ZSBpdCBjYW1lIGZyb20uXG4gICAqIEBwYXJhbSB4IHtudW1iZXJ9IHZhbHVlIG9mIHggYWxvbmcgdGhlIGJlemllciBjdXJ2ZSwgMC4wIDw9IHggPD0gMS4wXG4gICAqIEBwYXJhbSBlcHNpbG9uIHtudW1iZXJ9IGFjY3VyYWN5IGxpbWl0IG9mIHQgZm9yIHRoZSBnaXZlbiB4XG4gICAqIEByZXR1cm4ge251bWJlcn0gdGhlIHQgdmFsdWUgY29ycmVzcG9uZGluZyB0byB4XG4gICAqL1xuICB2YXIgc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgdmFyIHQwO1xuICAgIHZhciB0MTtcbiAgICB2YXIgdDI7XG4gICAgdmFyIHgyO1xuICAgIHZhciBkMjtcbiAgICB2YXIgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICB4MiA9IHNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgaWYgKE1hdGguYWJzICh4MikgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiB0MjtcbiAgICAgIH1cbiAgICAgIGQyID0gc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHQyID0gdDIgLSB4MiAvIGQyO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgYmlzZWN0aW9uIG1ldGhvZCBmb3IgcmVsaWFiaWxpdHkuXG4gICAgdDAgPSAwLjA7XG4gICAgdDEgPSAxLjA7XG4gICAgdDIgPSB4O1xuXG4gICAgaWYgKHQyIDwgdDApIHtcbiAgICAgIHJldHVybiB0MDtcbiAgICB9XG4gICAgaWYgKHQyID4gdDEpIHtcbiAgICAgIHJldHVybiB0MTtcbiAgICB9XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuICAgICAgeDIgPSBzYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgaWYgKE1hdGguYWJzKHgyIC0geCkgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiB0MjtcbiAgICAgIH1cbiAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgdDAgPSB0MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQxID0gdDI7XG4gICAgICB9XG4gICAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwO1xuICAgIH1cblxuICAgIC8vIEZhaWx1cmUuXG4gICAgcmV0dXJuIHQyO1xuICB9O1xuXG4gIC8qXG4gICAqIEBwYXJhbSB4IHtudW1iZXJ9IHRoZSB2YWx1ZSBvZiB4IGFsb25nIHRoZSBiZXppZXIgY3VydmUsIDAuMCA8PSB4IDw9IDEuMFxuICAgKiBAcGFyYW0gZXBzaWxvbiB7bnVtYmVyfSB0aGUgYWNjdXJhY3kgb2YgdCBmb3IgdGhlIGdpdmVuIHhcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgeSB2YWx1ZSBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlXG4gICAqL1xuICB2YXIgc29sdmUgPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIHNhbXBsZUN1cnZlWShzb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG4gIH07XG5cbiAgLy8gcHVibGljIGludGVyZmFjZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qXG4gICAqIEZpbmQgdGhlIHkgb2YgdGhlIGN1YmljLWJlemllciBmb3IgYSBnaXZlbiB4IHdpdGggYWNjdXJhY3kgZGV0ZXJtaW5lZCBieSB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0geCB7bnVtYmVyfSB0aGUgdmFsdWUgb2YgeCBhbG9uZyB0aGUgYmV6aWVyIGN1cnZlLCAwLjAgPD0geCA8PSAxLjBcbiAgICogQHBhcmFtIGR1cmF0aW9uIHtudW1iZXJ9IHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB5IHZhbHVlIGFsb25nIHRoZSBiZXppZXIgY3VydmVcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbih4LCBkdXJhdGlvbikge1xuICAgIHJldHVybiBzb2x2ZSh4LCBzb2x2ZUVwc2lsb24oK2R1cmF0aW9uIHx8IERFRkFVTFRfRFVSQVRJT04pKTtcbiAgfTtcbn1cblxuXG59LHt9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQSBIVUdFIHRoYW5rIHlvdSB0byBkeW5hbWljcy5qcyB3aGljaCBpbnNwaXJlZCB0aGVzZSBkeW5hbWljcyBzaW11bGF0aW9ucy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsdmlsbGFyL2R5bmFtaWNzLmpzXG4gKlxuICogQWxzbyBsaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG52YXIgZXh0ZW5kID0gX2RlcmVxXygnLi4vdXRpbC9leHRlbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNwcmluZzogZHluYW1pY3NTcHJpbmcsXG4gIGdyYXZpdHk6IGR5bmFtaWNzR3Jhdml0eVxufTtcblxudmFyIHNwcmluZ0RlZmF1bHRzID0ge1xuICBmcmVxdWVuY3k6IDE1LFxuICBmcmljdGlvbjogMjAwLFxuICBhbnRpY2lwYXRpb25TdHJlbmd0aDogMCxcbiAgYW50aWNpcGF0aW9uU2l6ZTogMFxufTtcbmZ1bmN0aW9uIGR5bmFtaWNzU3ByaW5nKG9wdHMpIHtcbiAgb3B0cyA9IGV4dGVuZCh7fSwgc3ByaW5nRGVmYXVsdHMsIG9wdHMgfHwge30pO1xuXG4gIHJldHVybiBmdW5jdGlvbiBhdCh0LCBkdXJhdGlvbikge1xuICAgIHZhciBBLCBBdCwgYSwgYW5nbGUsIGIsIGRlY2FsLCBmcmVxdWVuY3ksIGZyaWN0aW9uLCBmcmljdGlvblQsIHMsIHYsIHkwLCB5UyxcbiAgICBfb3B0cyA9IG9wdHM7XG4gICAgZnJlcXVlbmN5ID0gTWF0aC5tYXgoMSwgb3B0cy5mcmVxdWVuY3kpO1xuICAgIGZyaWN0aW9uID0gTWF0aC5wb3coMjAsIG9wdHMuZnJpY3Rpb24gLyAxMDApO1xuICAgIHMgPSBvcHRzLmFudGljaXBhdGlvblNpemUgLyAxMDA7XG4gICAgZGVjYWwgPSBNYXRoLm1heCgwLCBzKTtcbiAgICBmcmljdGlvblQgPSAodCAvICgxIC0gcykpIC0gKHMgLyAoMSAtIHMpKTtcbiAgICBpZiAodCA8IHMpIHtcbiAgICAgIEEgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBNLCBhLCBiLCB4MCwgeDE7XG4gICAgICAgIE0gPSAwLjg7XG4gICAgICAgIHgwID0gcyAvICgxIC0gcyk7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgYiA9ICh4MCAtIChNICogeDEpKSAvICh4MCAtIHgxKTtcbiAgICAgICAgYSA9IChNIC0gYikgLyB4MDtcbiAgICAgICAgcmV0dXJuIChhICogdCAqIF9vcHRzLmFudGljaXBhdGlvblN0cmVuZ3RoIC8gMTAwKSArIGI7XG4gICAgICB9O1xuICAgICAgeVMgPSAocyAvICgxIC0gcykpIC0gKHMgLyAoMSAtIHMpKTtcbiAgICAgIHkwID0gKDAgLyAoMSAtIHMpKSAtIChzIC8gKDEgLSBzKSk7XG4gICAgICBiID0gTWF0aC5hY29zKDEgLyBBKHlTKSk7XG4gICAgICBhID0gKE1hdGguYWNvcygxIC8gQSh5MCkpIC0gYikgLyAoZnJlcXVlbmN5ICogKC1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEEgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhmcmljdGlvbiAvIDEwLCAtdCkgKiAoMSAtIHQpO1xuICAgICAgfTtcbiAgICAgIGIgPSAwO1xuICAgICAgYSA9IDE7XG4gICAgfVxuICAgIEF0ID0gQShmcmljdGlvblQpO1xuICAgIGFuZ2xlID0gZnJlcXVlbmN5ICogKHQgLSBzKSAqIGEgKyBiO1xuICAgIHYgPSAxIC0gKEF0ICogTWF0aC5jb3MoYW5nbGUpKTtcbiAgICAvL3JldHVybiBbdCwgdiwgQXQsIGZyaWN0aW9uVCwgYW5nbGVdO1xuICAgIHJldHVybiB2O1xuICB9O1xufVxuXG52YXIgZ3Jhdml0eURlZmF1bHRzID0ge1xuICBib3VuY2U6IDQwLFxuICBncmF2aXR5OiAxMDAwLFxuICBpbml0aWFsRm9yY2U6IGZhbHNlXG59O1xuZnVuY3Rpb24gZHluYW1pY3NHcmF2aXR5KG9wdHMpIHtcbiAgb3B0cyA9IGV4dGVuZCh7fSwgZ3Jhdml0eURlZmF1bHRzLCBvcHRzIHx8IHt9KTtcbiAgdmFyIGN1cnZlcyA9IFtdO1xuXG4gIGluaXQoKTtcblxuICByZXR1cm4gYXQ7XG5cbiAgZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBMLCBiLCBib3VuY2UsIGN1cnZlLCBncmF2aXR5O1xuICAgIGJvdW5jZSA9IE1hdGgubWluKG9wdHMuYm91bmNlIC8gMTAwLCA4MCk7XG4gICAgZ3Jhdml0eSA9IG9wdHMuZ3Jhdml0eSAvIDEwMDtcbiAgICBiID0gTWF0aC5zcXJ0KDIgLyBncmF2aXR5KTtcbiAgICBjdXJ2ZSA9IHtcbiAgICAgIGE6IC1iLFxuICAgICAgYjogYixcbiAgICAgIEg6IDFcbiAgICB9O1xuICAgIGlmIChvcHRzLmluaXRpYWxGb3JjZSkge1xuICAgICAgY3VydmUuYSA9IDA7XG4gICAgICBjdXJ2ZS5iID0gY3VydmUuYiAqIDI7XG4gICAgfVxuICAgIHdoaWxlIChjdXJ2ZS5IID4gMC4wMDEpIHtcbiAgICAgIEwgPSBjdXJ2ZS5iIC0gY3VydmUuYTtcbiAgICAgIGN1cnZlID0ge1xuICAgICAgICBhOiBjdXJ2ZS5iLFxuICAgICAgICBiOiBjdXJ2ZS5iICsgTCAqIGJvdW5jZSxcbiAgICAgICAgSDogY3VydmUuSCAqIGJvdW5jZSAqIGJvdW5jZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlLmI7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHZhciBMLCBiLCBib3VuY2UsIGN1cnZlLCBncmF2aXR5LCBfcmVzdWx0cztcblxuICAgIEwgPSBsZW5ndGgoKTtcbiAgICBncmF2aXR5ID0gKG9wdHMuZ3Jhdml0eSAvIDEwMCkgKiBMICogTDtcbiAgICBib3VuY2UgPSBNYXRoLm1pbihvcHRzLmJvdW5jZSAvIDEwMCwgODApO1xuICAgIGIgPSBNYXRoLnNxcnQoMiAvIGdyYXZpdHkpO1xuICAgIGN1cnZlcyA9IFtdO1xuICAgIGN1cnZlID0ge1xuICAgICAgYTogLWIsXG4gICAgICBiOiBiLFxuICAgICAgSDogMVxuICAgIH07XG4gICAgaWYgKG9wdHMuaW5pdGlhbEZvcmNlKSB7XG4gICAgICBjdXJ2ZS5hID0gMDtcbiAgICAgIGN1cnZlLmIgPSBjdXJ2ZS5iICogMjtcbiAgICB9XG4gICAgY3VydmVzLnB1c2goY3VydmUpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGN1cnZlLmIgPCAxICYmIGN1cnZlLkggPiAwLjAwMSkge1xuICAgICAgTCA9IGN1cnZlLmIgLSBjdXJ2ZS5hO1xuICAgICAgY3VydmUgPSB7XG4gICAgICAgIGE6IGN1cnZlLmIsXG4gICAgICAgIGI6IGN1cnZlLmIgKyBMICogYm91bmNlLFxuICAgICAgICBIOiBjdXJ2ZS5IICogYm91bmNlICogYm91bmNlXG4gICAgICB9O1xuICAgICAgX3Jlc3VsdHMucHVzaChjdXJ2ZXMucHVzaChjdXJ2ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVDdXJ2ZShhLCBiLCBILCB0KXtcbiAgICB2YXIgTCwgYywgdDI7XG4gICAgTCA9IGIgLSBhO1xuICAgIHQyID0gKDIgLyBMKSAqIHQgLSAxIC0gKGEgKiAyIC8gTCk7XG4gICAgYyA9IHQyICogdDIgKiBIIC0gSCArIDE7XG4gICAgaWYgKG9wdHMuaW5pdGlhbEZvcmNlKSB7XG4gICAgICBjID0gMSAtIGM7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gYXQodCwgZHVyYXRpb24pIHtcbiAgICB2YXIgYm91bmNlLCBjdXJ2ZSwgZ3Jhdml0eSwgaSwgdjtcbiAgICBib3VuY2UgPSBvcHRzLmJvdW5jZSAvIDEwMDtcbiAgICBncmF2aXR5ID0gb3B0cy5ncmF2aXR5O1xuICAgIGkgPSAwO1xuICAgIGN1cnZlID0gY3VydmVzW2ldO1xuICAgIHdoaWxlICghKHQgPj0gY3VydmUuYSAmJiB0IDw9IGN1cnZlLmIpKSB7XG4gICAgICBpICs9IDE7XG4gICAgICBjdXJ2ZSA9IGN1cnZlc1tpXTtcbiAgICAgIGlmICghY3VydmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY3VydmUpIHtcbiAgICAgIHYgPSBvcHRzLmluaXRpYWxGb3JjZSA/IDAgOiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gY2FsY3VsYXRlQ3VydmUoY3VydmUuYSwgY3VydmUuYiwgY3VydmUuSCwgdCk7XG4gICAgfVxuICAgIC8vcmV0dXJuIFt0LCB2XTtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG59O1xuXG59LHtcIi4uL3V0aWwvZXh0ZW5kXCI6MTB9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBkeW5hbWljcyA9IF9kZXJlcV8oJy4vZHluYW1pY3MnKTtcbnZhciBiZXppZXIgPSBfZGVyZXFfKCcuL2JlemllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJ2xpbmVhcic6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0LCBkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIGJlemllci5saW5lYXIodCwgZHVyYXRpb24pO1xuICAgIH07XG4gIH0sXG4gICdlYXNlJzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gYmV6aWVyLmVhc2UodCwgZHVyYXRpb24pO1xuICAgIH07XG4gIH0sXG4gICdlYXNlLWluJzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gYmV6aWVyLmVhc2VJbih0LCBkdXJhdGlvbik7XG4gICAgfTtcbiAgfSxcbiAgJ2Vhc2Utb3V0JzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gYmV6aWVyLmVhc2VPdXQodCwgZHVyYXRpb24pO1xuICAgIH07XG4gIH0sXG4gICdlYXNlLWluLW91dCc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbih0LCBkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIGJlemllci5lYXNlSW5PdXQodCwgZHVyYXRpb24pO1xuICAgIH07XG4gIH0sXG4gICdjdWJpYy1iZXppZXInOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZHVyYXRpb24pIHtcbiAgICB2YXIgYnogPSBiZXppZXIuY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpOy8vLCB0LCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQsIGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gYnoodCwgZHVyYXRpb24pO1xuICAgIH07XG4gIH1cbn07XG5cbn0se1wiLi9iZXppZXJcIjo1LFwiLi9keW5hbWljc1wiOjZ9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxudmFyIHJhZiA9IF9kZXJlcV8oJ3JhZicpO1xudmFyIHRpbWUgPSBfZGVyZXFfKCdwZXJmb3JtYW5jZS1ub3cnKTtcblxudmFyIHNlbGYgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgX2FjdGlvbnM6IHt9LFxuICBpc1RpY2tpbmc6IGZhbHNlLFxuXG4gIHRpY2tBY3Rpb246IGZ1bmN0aW9uKGlkLCBhY3Rpb24pIHtcbiAgICBzZWxmLl9hY3Rpb25zW2lkXSA9IGFjdGlvbjtcblxuICAgIGlmICghc2VsZi5pc1RpY2tpbmcpIHtcbiAgICAgIHNlbGYudGljaygpO1xuICAgIH1cbiAgfSxcblxuICB1bnRpY2tBY3Rpb246IGZ1bmN0aW9uKGlkKSB7XG4gICAgZGVsZXRlIHNlbGYuX2FjdGlvbnNbaWRdO1xuICAgIHNlbGYubWF5YmVTdG9wVGlja2luZygpO1xuICB9LFxuXG4gIHRpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXN0RnJhbWUgPSB0aW1lKCk7XG5cbiAgICBzZWxmLmlzVGlja2luZyA9IHRydWU7XG4gICAgc2VsZi5fcmFmSWQgPSByYWYoc3RlcCk7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgc2VsZi5fcmFmSWQgPSByYWYoc3RlcCk7XG5cbiAgICAgIC8vIEdldCBjdXJyZW50IHRpbWVcbiAgICAgIHZhciBub3cgPSB0aW1lKCk7XG4gICAgICB2YXIgZGVsdGFUID0gbm93IC0gbGFzdEZyYW1lO1xuXG4gICAgICBmb3IgKHZhciBpZCBpbiBzZWxmLl9hY3Rpb25zKSB7XG4gICAgICAgIHNlbGYuX2FjdGlvbnNbaWRdKGRlbHRhVCk7XG4gICAgICB9XG5cbiAgICAgIGxhc3RGcmFtZSA9IG5vdztcbiAgICB9XG4gIH0sXG5cbiAgbWF5YmVTdG9wVGlja2luZzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuaXNUaWNraW5nICYmICFPYmplY3Qua2V5cyhzZWxmLl9hY3Rpb25zKS5sZW5ndGgpIHtcbiAgICAgIHJhZi5jYW5jZWwoc2VsZi5fcmFmSWQpO1xuICAgICAgc2VsZi5pc1RpY2tpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbn07XG5cblxufSx7XCJwZXJmb3JtYW5jZS1ub3dcIjoxLFwicmFmXCI6Mn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFuaW1hdGlvbjogX2RlcmVxXygnLi9hbmltYXRpb24nKVxufTtcblxufSx7XCIuL2FuaW1hdGlvblwiOjR9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qXG4gKiBUaGVyZSByZWFsbHkgaXMgbm8gdGlueSBtaW5pbWFsIGV4dGVuZCgpIG9uIG5wbSB0byBmaW5kLFxuICogc28gd2UganVzdCB1c2Ugb3VyIG93bi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgIHZhciBzb3VyY2UgPSBhcmdzW2ldO1xuICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICB9XG4gICAgIH1cbiAgIH1cbiAgIHJldHVybiBvYmo7XG59O1xuXG59LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbi8vIEFsbCB3ZSB3YW50IGlzIGFuIGV2ZW50RW1pdHRlciB0aGF0IGRvZXNuJ3QgdXNlICNjYWxsIG9yICNhcHBseSxcbi8vIGJ5IGV4cGVjdGluZyAwLTEgYXJndW1lbnRzLiBcbi8vIFdlIGNvdWxkbid0IGZpbmQgdGhpcyBvbiBucG0sIHNvIHdlIG1ha2Ugb3VyIG93bi5cblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudEVtaXR0ZXI7XG5cbmZ1bmN0aW9uIFNpbXBsZUV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn1cblxuU2ltcGxlRXZlbnRFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSB8fCAodGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdKTtcbiAgICB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdLnB1c2goZm4pO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbihldmVudFR5cGUsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uY2VGbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50VHlwZSwgZm4pO1xuICAgICAgc2VsZi5vZmYoZXZlbnRUeXBlLCBvbmNlRm4pO1xuICAgIH1cbiAgICB0aGlzLm9uKGV2ZW50VHlwZSwgZm4pO1xuICAgIHRoaXMub24oZXZlbnRUeXBlLCBvbmNlRm4pO1xuICB9LFxuICAvLyBCdWlsdC1pbiBsaW1pdGF0aW9uOiB3ZSBvbmx5IGV4cGVjdCAwLTEgYXJndW1lbnRzXG4gIC8vIFRoaXMgaXMgdG8gc2F2ZSBhcyBtdWNoIHBlcmYgYXMgcG9zc2libGUgd2hlbiBzZW5kaW5nXG4gIC8vIGV2ZW50cyBldmVyeSBmcmFtZS5cbiAgZW1pdDogZnVuY3Rpb24oZXZlbnRUeXBlLCBldmVudEFyZykge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdIHx8IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIGxpc3RlbmVyc1tpXSAmJiBsaXN0ZW5lcnNbaV0oZXZlbnRBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykgbGlzdGVuZXJzW2ldICYmIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbihldmVudFR5cGUsIGZuVG9SZW1vdmUpIHtcbiAgICBpZiAoIWV2ZW50VHlwZSkge1xuICAgICAgLy9SZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICB0aGlzLm9mZih0eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBpZiAoIWZuVG9SZW1vdmUpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihmblRvUmVtb3ZlKTtcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBcbn07XG5cbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBuZXh0VWlkKCkgZnJvbSBhbmd1bGFyLmpzXG4gKiBMaWNlbnNlIE1JVFxuICogaHR0cDovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzXG4gKlxuICogQSBjb25zaXN0ZW50IHdheSBvZiBjcmVhdGluZyB1bmlxdWUgSURzIGluIGFuZ3VsYXIuIFRoZSBJRCBpcyBhIHNlcXVlbmNlIG9mIGFscGhhIG51bWVyaWNcbiAqIGNoYXJhY3RlcnMgc3VjaCBhcyAnMDEyQUJDJy4gVGhlIHJlYXNvbiB3aHkgd2UgYXJlIG5vdCB1c2luZyBzaW1wbHkgYSBudW1iZXIgY291bnRlciBpcyB0aGF0XG4gKiB0aGUgbnVtYmVyIHN0cmluZyBnZXRzIGxvbmdlciBvdmVyIHRpbWUsIGFuZCBpdCBjYW4gYWxzbyBvdmVyZmxvdywgd2hlcmUgYXMgdGhlIG5leHRJZFxuICogd2lsbCBncm93IG11Y2ggc2xvd2VyLCBpdCBpcyBhIHN0cmluZywgYW5kIGl0IHdpbGwgbmV2ZXIgb3ZlcmZsb3cuXG4gKlxuICogQHJldHVybnMgYW4gdW5pcXVlIGFscGhhLW51bWVyaWMgc3RyaW5nXG4gKi9cbnZhciB1aWQgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXh0VWlkKCkge1xuICB2YXIgaW5kZXggPSB1aWQubGVuZ3RoO1xuICB2YXIgZGlnaXQ7XG5cbiAgd2hpbGUoaW5kZXgpIHtcbiAgICBpbmRleC0tO1xuICAgIGRpZ2l0ID0gdWlkW2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChkaWdpdCA9PSA1NyAvKic5JyovKSB7XG4gICAgICB1aWRbaW5kZXhdID0gJ0EnO1xuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0ID09IDkwICAvKidaJyovKSB7XG4gICAgICB1aWRbaW5kZXhdID0gJzAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1aWRbaW5kZXhdID0gU3RyaW5nLmZyb21DaGFyQ29kZShkaWdpdCArIDEpO1xuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbiAgICB9XG4gIH1cbiAgdWlkLnVuc2hpZnQoJzAnKTtcbiAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbn07XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XX0se30sWzldKVxuKDkpXG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ib3dlcl9jb21wb25lbnRzXFxcXGNvbGxpZGVcXFxcY29sbGlkZS5qc1wiLFwiL2Jvd2VyX2NvbXBvbmVudHNcXFxcY29sbGlkZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbihmdW5jdGlvbihpb25pYykge1xyXG5cclxuICAvLyBHZXQgdHJhbnNmb3JtIG9yaWdpbiBwb2x5XHJcbiAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICB2YXIgdHJhbnNmb3JtS2V5cyA9IFsnd2Via2l0VHJhbnNmb3JtT3JpZ2luJywgJ3RyYW5zZm9ybS1vcmlnaW4nLCAnLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luJywgJ3dlYmtpdC10cmFuc2Zvcm0tb3JpZ2luJyxcclxuICAgICAgICAgICAgICAnLW1vei10cmFuc2Zvcm0tb3JpZ2luJywgJ21vei10cmFuc2Zvcm0tb3JpZ2luJywgJ01velRyYW5zZm9ybU9yaWdpbicsICdtb3pUcmFuc2Zvcm1PcmlnaW4nXTtcclxuXHJcbiAgdmFyIFRSQU5TRk9STV9PUklHSU4gPSAnd2Via2l0VHJhbnNmb3JtT3JpZ2luJztcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYoZC5zdHlsZVt0cmFuc2Zvcm1LZXlzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIFRSQU5TRk9STV9PUklHSU4gPSB0cmFuc2Zvcm1LZXlzW2ldO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciB0cmFuc2l0aW9uS2V5cyA9IFsnd2Via2l0VHJhbnNpdGlvbicsICd0cmFuc2l0aW9uJywgJy13ZWJraXQtdHJhbnNpdGlvbicsICd3ZWJraXQtdHJhbnNpdGlvbicsXHJcbiAgICAgICAgICAgICAgJy1tb3otdHJhbnNpdGlvbicsICdtb3otdHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21velRyYW5zaXRpb24nXTtcclxuICB2YXIgVFJBTlNJVElPTiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgdHJhbnNpdGlvbktleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmKGQuc3R5bGVbdHJhbnNpdGlvbktleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgVFJBTlNJVElPTiA9IHRyYW5zaXRpb25LZXlzW2ldO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBTd2lwZWFibGVDYXJkVmlldyA9IGlvbmljLnZpZXdzLlZpZXcuaW5oZXJpdCh7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgYSBjYXJkIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdHMpIHtcclxuICAgICAgb3B0cyA9IGlvbmljLmV4dGVuZCh7XHJcbiAgICAgIH0sIG9wdHMpO1xyXG5cclxuICAgICAgaW9uaWMuZXh0ZW5kKHRoaXMsIG9wdHMpO1xyXG5cclxuICAgICAgdGhpcy5lbCA9IG9wdHMuZWw7XHJcblxyXG4gICAgICB0aGlzLnBhcmVudFdpZHRoID0gdGhpcy5lbC5wYXJlbnROb2RlLm9mZnNldFdpZHRoO1xyXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5lbC5vZmZzZXRXaWR0aDtcclxuXHJcbiAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy5zdGFydFkgPSB0aGlzLnggPSB0aGlzLnkgPSAwO1xyXG5cclxuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBYIHBvc2l0aW9uIG9mIHRoZSBjYXJkLlxyXG4gICAgICovXHJcbiAgICBzZXRYOiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHRoaXMuZWwuc3R5bGVbaW9uaWMuQ1NTLlRSQU5TRk9STV0gPSAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsJyArIHRoaXMueSArICdweCwgMCknO1xyXG4gICAgICB0aGlzLnggPSB4O1xyXG4gICAgICB0aGlzLnN0YXJ0WCA9IHg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBZIHBvc2l0aW9uIG9mIHRoZSBjYXJkLlxyXG4gICAgICovXHJcbiAgICBzZXRZOiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHRoaXMuZWwuc3R5bGVbaW9uaWMuQ1NTLlRSQU5TRk9STV0gPSAndHJhbnNsYXRlM2QoJyArIHRoaXMueCArICdweCwnICsgeSArICdweCwgMCknO1xyXG4gICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICB0aGlzLnN0YXJ0WSA9IHk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBaLUluZGV4IG9mIHRoZSBjYXJkXHJcbiAgICAgKi9cclxuICAgIHNldFpJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgdGhpcy5lbC5zdHlsZS56SW5kZXggPSBpbmRleDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHdpZHRoIG9mIHRoZSBjYXJkXHJcbiAgICAgKi9cclxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICB0aGlzLmVsLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjYXJkXHJcbiAgICAgKi9cclxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICAgIHRoaXMuZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGR1cmF0aW9uIHRvIHJ1biB0aGUgcG9wLWluIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBzZXRQb3BJbkR1cmF0aW9uOiBmdW5jdGlvbihkdXJhdGlvbikge1xyXG4gICAgICB0aGlzLmNhcmRQb3BJbkR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNpdGlvbiBpbiB0aGUgY2FyZCB3aXRoIHRoZSBnaXZlbiBhbmltYXRpb24gY2xhc3NcclxuICAgICAqL1xyXG4gICAgdHJhbnNpdGlvbkluOiBmdW5jdGlvbihhbmltYXRpb25DbGFzcykge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoYW5pbWF0aW9uQ2xhc3MgKyAnLXN0YXJ0Jyk7XHJcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZChhbmltYXRpb25DbGFzcyk7XHJcbiAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5lbC5jbGFzc0xpc3QucmVtb3ZlKGFuaW1hdGlvbkNsYXNzICsgJy1zdGFydCcpO1xyXG4gICAgICB9LCAxMDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgdHJhbnNpdGlvbnMgb24gdGhlIGNhcmQgKGZvciB3aGVuIGRyYWdnaW5nKVxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlVHJhbnNpdGlvbjogZnVuY3Rpb24oYW5pbWF0aW9uQ2xhc3MpIHtcclxuICAgICAgdGhpcy5lbC5jbGFzc0xpc3QucmVtb3ZlKGFuaW1hdGlvbkNsYXNzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTd2lwZSBhIGNhcmQgb3V0IHByb2dyYW10aWNhbGx5XHJcbiAgICAgKi9cclxuICAgIHN3aXBlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy50cmFuc2l0aW9uT3V0KCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFNuYXAgdGhlIGNhcmQgYmFjayB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgc25hcEJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLm9uU25hcEJhY2sodGhpcy54LCB0aGlzLnksIHRoaXMucm90YXRpb25BbmdsZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzVW5kZXJUaHJlc2hvbGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvL3JldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy50aHJlc2hvbGRBbW91bnQpIDwgMC40O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogRmx5IHRoZSBjYXJkIG91dCBvciBhbmltYXRlIGJhY2sgaW50byByZXN0aW5nIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICB0cmFuc2l0aW9uT3V0OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgIGlmKHRoaXMuaXNVbmRlclRocmVzaG9sZCgpKSB7XHJcbiAgICAgICAgc2VsZi5vblNuYXBCYWNrKHRoaXMueCwgdGhpcy55LCB0aGlzLnJvdGF0aW9uQW5nbGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgc2VsZi5vblRyYW5zaXRpb25PdXQoc2VsZi50aHJlc2hvbGRBbW91bnQpO1xyXG4gICAgICBcclxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGUuZ2VzdHVyZS5kZWx0YVggLyBlLmdlc3R1cmUuZGVsdGFZKTtcclxuXHJcbiAgICAgIHZhciBkaXIgPSB0aGlzLnRocmVzaG9sZEFtb3VudCA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIHZhciB0YXJnZXRYO1xyXG4gICAgICBpZih0aGlzLnggPiAwKSB7XHJcbiAgICAgICAgdGFyZ2V0WCA9ICh0aGlzLnBhcmVudFdpZHRoIC8gMikgKyAodGhpcy53aWR0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGFyZ2V0WCA9IC0gKHRoaXMucGFyZW50V2lkdGggKyB0aGlzLndpZHRoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGFyZ2V0IFkgaXMganVzdCB0aGUgXCJvcHBvc2l0ZVwiIHNpZGUgb2YgdGhlIHRyaWFuZ2xlIG9mIHRhcmdldFggYXMgdGhlIGFkamFjZW50IGVkZ2UgKHNvaGNhaHRvYSB5bylcclxuICAgICAgdmFyIHRhcmdldFkgPSB0YXJnZXRYIC8gTWF0aC50YW4oYW5nbGUpO1xyXG5cclxuICAgICAgLy8gRmx5IG91dFxyXG4gICAgICB2YXIgcm90YXRlVG8gPSB0aGlzLnJvdGF0aW9uQW5nbGU7Ly8odGhpcy5yb3RhdGlvbkFuZ2xlIHRoaXMucm90YXRpb25EaXJlY3Rpb24gKiAwLjIpKTsvLyB8fCAoTWF0aC5yYW5kb20oKSAqIDAuNCk7XHJcblxyXG4gICAgICB2YXIgZHVyYXRpb24gPSAwLjMgLSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyhlLmdlc3R1cmUudmVsb2NpdHlYKS8xMCwgMC4wNSksIDAuMik7XHJcbiAgICAgIFxyXG4gICAgICBpb25pYy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5lbC5zdHlsZS50cmFuc2Zvcm0gPSBzZWxmLmVsLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgdGFyZ2V0WCArICdweCwgJyArIHRhcmdldFkgKyAncHgsMCkgcm90YXRlKCcgKyBzZWxmLnJvdGF0aW9uQW5nbGUgKyAncmFkKSc7XHJcbiAgICAgICAgc2VsZi5lbC5zdHlsZS50cmFuc2l0aW9uID0gc2VsZi5lbC5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJ2FsbCAnICsgZHVyYXRpb24gKyAncyBlYXNlLWluLW91dCc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy90aGlzLm9uU3dpcGUgJiYgdGhpcy5vblN3aXBlKCk7XHJcblxyXG4gICAgICAvLyBUcmlnZ2VyIGRlc3Ryb3kgYWZ0ZXIgY2FyZCBoYXMgc3dpcGVkIG91dFxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYub25EZXN0cm95ICYmIHNlbGYub25EZXN0cm95KCk7XHJcbiAgICAgIH0sIGR1cmF0aW9uICogMTAwMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmluZCBkcmFnIGV2ZW50cyBvbiB0aGUgY2FyZC5cclxuICAgICAqL1xyXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgaW9uaWMub25HZXN0dXJlKCdkcmFnc3RhcnQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgY3ggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDI7XHJcbiAgICAgICAgaWYoZS5nZXN0dXJlLnRvdWNoZXNbMF0ucGFnZVggPCBjeCkge1xyXG4gICAgICAgICAgc2VsZi5fdHJhbnNmb3JtT3JpZ2luUmlnaHQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZi5fdHJhbnNmb3JtT3JpZ2luTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgICAgIGlvbmljLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHsgc2VsZi5fZG9EcmFnU3RhcnQoZSkgfSk7XHJcbiAgICAgIH0sIHRoaXMuZWwpO1xyXG5cclxuICAgICAgaW9uaWMub25HZXN0dXJlKCdkcmFnJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGlvbmljLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHsgc2VsZi5fZG9EcmFnKGUpIH0pO1xyXG4gICAgICAgIC8vIEluZGljYXRlIHdlIHdhbnQgdG8gc3RvcCBwYXJlbnRzIGZyb20gdXNpbmcgdGhpc1xyXG4gICAgICAgIGUuZ2VzdHVyZS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9LCB0aGlzLmVsKTtcclxuXHJcbiAgICAgIGlvbmljLm9uR2VzdHVyZSgnZHJhZ2VuZCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICBpb25pYy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7IHNlbGYuX2RvRHJhZ0VuZChlKSB9KTtcclxuICAgICAgfSwgdGhpcy5lbCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJvdGF0ZSBhbmNob3JlZCB0byB0aGUgbGVmdCBvZiB0aGUgc2NyZWVuXHJcbiAgICBfdHJhbnNmb3JtT3JpZ2luTGVmdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuZWwuc3R5bGVbVFJBTlNGT1JNX09SSUdJTl0gPSAnbGVmdCBjZW50ZXInO1xyXG4gICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID0gMTtcclxuICAgIH0sXHJcblxyXG4gICAgX3RyYW5zZm9ybU9yaWdpblJpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5lbC5zdHlsZVtUUkFOU0ZPUk1fT1JJR0lOXSA9ICdyaWdodCBjZW50ZXInO1xyXG4gICAgICB0aGlzLnJvdGF0aW9uRGlyZWN0aW9uID0gLTE7XHJcbiAgICB9LFxyXG5cclxuICAgIF9kb0RyYWdTdGFydDogZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XHJcbiAgICAgIHZhciBwb2ludCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMiArIHRoaXMucm90YXRpb25EaXJlY3Rpb24gKiAod2lkdGggLyAyKVxyXG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhwb2ludCAtIGUuZ2VzdHVyZS50b3VjaGVzWzBdLnBhZ2VYKTsvLyAtIHdpbmRvdy5pbm5lcldpZHRoLzIpO1xyXG5cclxuICAgICAgdGhpcy50b3VjaERpc3RhbmNlID0gZGlzdGFuY2UgKiAxMDtcclxuICAgIH0sXHJcblxyXG4gICAgX2RvRHJhZzogZnVuY3Rpb24oZSkge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICB2YXIgbyA9IGUuZ2VzdHVyZS5kZWx0YVggLyAtMTAwMDtcclxuXHJcbiAgICAgIHRoaXMucm90YXRpb25BbmdsZSA9IE1hdGguYXRhbihvKTtcclxuXHJcbiAgICAgIHRoaXMueCA9IHRoaXMuc3RhcnRYICsgKGUuZ2VzdHVyZS5kZWx0YVggKiAwLjgpO1xyXG4gICAgICB0aGlzLnkgPSB0aGlzLnN0YXJ0WSArIChlLmdlc3R1cmUuZGVsdGFZICogMC44KTtcclxuXHJcbiAgICAgIHRoaXMuZWwuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5lbC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIHRoaXMueCArICdweCwgJyArIHRoaXMueSAgKyAncHgsIDApIHJvdGF0ZSgnICsgKHRoaXMucm90YXRpb25BbmdsZSB8fCAwKSArICdyYWQpJztcclxuXHJcblxyXG4gICAgICB0aGlzLnRocmVzaG9sZEFtb3VudCA9ICh0aGlzLnggLyAodGhpcy5wYXJlbnRXaWR0aC8yKSk7XHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5vblBhcnRpYWxTd2lwZShzZWxmLnRocmVzaG9sZEFtb3VudCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIF9kb0RyYWdFbmQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgdGhpcy50cmFuc2l0aW9uT3V0KGUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuXHJcbiAgYW5ndWxhci5tb2R1bGUoJ2lvbmljLmNvbnRyaWIudWkudGluZGVyQ2FyZHMnLCBbJ2lvbmljJ10pXHJcblxyXG4gIC5kaXJlY3RpdmUoJ3RkQ2FyZCcsIFsnJHRpbWVvdXQnLCBmdW5jdGlvbigkdGltZW91dCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBub24tbGluZWFyIGZhZGUgZnVuY3Rpb24gZm9yIHRoZSB0ZXh0IG9uIGVhY2ggY2FyZFxyXG4gICAgICovXHJcbiAgICB2YXIgZmFkZUZuID0gZnVuY3Rpb24odCkge1xyXG4gICAgICAvLyBTcGVlZCB1cCB0aW1lIHRvIHJhbXAgdXAgcXVpY2tseVxyXG4gICAgICB0ID0gTWF0aC5taW4oMSwgdCAqIDMpO1xyXG5cclxuICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsZSBjdWJpYyBiZXppZXIgY3VydmUuXHJcbiAgICAgIC8vIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tLyMuMTEsLjY3LC40MSwuOTlcclxuICAgICAgdmFyIGMxID0gMC4xMSxcclxuICAgICAgICAgIGMyID0gMC42NyxcclxuICAgICAgICAgIGMzID0gMC40MSxcclxuICAgICAgICAgIGM0ID0gMC45OTtcclxuXHJcbiAgICAgIHJldHVybiBNYXRoLnBvdygoMSAtIHQpLCAzKSpjMSArIDMqTWF0aC5wb3coKDEgLSAgdCksIDIpKnQqYzIgKyAzKigxIC0gdCkqdCp0KmMzICsgTWF0aC5wb3codCwgMykqYzQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRkLWNhcmRcIiBuZy10cmFuc2NsdWRlPjwvZGl2PicsXHJcbiAgICAgIHJlcXVpcmU6ICdedGRDYXJkcycsXHJcbiAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgIHNjb3BlOiB7XHJcbiAgICAgICAgb25Td2lwZUxlZnQ6ICcmJyxcclxuICAgICAgICBvblN3aXBlUmlnaHQ6ICcmJyxcclxuICAgICAgICBvblRyYW5zaXRpb25MZWZ0OiAnJicsXHJcbiAgICAgICAgb25UcmFuc2l0aW9uUmlnaHQ6ICcmJyxcclxuICAgICAgICBvblRyYW5zaXRpb25PdXQ6ICcmJyxcclxuICAgICAgICBvblBhcnRpYWxTd2lwZTogJyYnLFxyXG4gICAgICAgIG9uU25hcEJhY2s6ICcmJyxcclxuICAgICAgICBvbkRlc3Ryb3k6ICcmJ1xyXG4gICAgICB9LFxyXG4gICAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRyLCBzd2lwZUNhcmRzKSB7XHJcbiAgICAgICAgICB2YXIgZWwgPSAkZWxlbWVudFswXTtcclxuICAgICAgICAgIHZhciBsZWZ0VGV4dCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5uby10ZXh0Jyk7XHJcbiAgICAgICAgICB2YXIgcmlnaHRUZXh0ID0gZWwucXVlcnlTZWxlY3RvcignLnllcy10ZXh0Jyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEZvcmNlIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiBmb3IgYW5pbWF0aW9uIC0gYmV0dGVyIHBlcmZvcm1hbmNlIG9uIGZpcnN0IHRvdWNoXHJcbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2Zvcm0gPSBlbC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknO1xyXG5cclxuICAgICAgICAgIC8vIEluc3RhbnRpYXRlIG91ciBjYXJkIHZpZXdcclxuICAgICAgICAgIHZhciBzd2lwZWFibGVDYXJkID0gbmV3IFN3aXBlYWJsZUNhcmRWaWV3KHtcclxuICAgICAgICAgICAgZWw6IGVsLFxyXG4gICAgICAgICAgICBsZWZ0VGV4dDogbGVmdFRleHQsXHJcbiAgICAgICAgICAgIHJpZ2h0VGV4dDogcmlnaHRUZXh0LFxyXG4gICAgICAgICAgICBvblBhcnRpYWxTd2lwZTogZnVuY3Rpb24oYW10KSB7XHJcbiAgICAgICAgICAgICAgc3dpcGVDYXJkcy5wYXJ0aWFsKGFtdCk7XHJcbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFtdCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdFRleHQpIHNlbGYubGVmdFRleHQuc3R5bGUub3BhY2l0eSA9IGZhZGVGbigtYW10KTtcclxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGYucmlnaHRUZXh0KSBzZWxmLnJpZ2h0VGV4dC5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxlZnRUZXh0KSBzZWxmLmxlZnRUZXh0LnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodFRleHQpIHNlbGYucmlnaHRUZXh0LnN0eWxlLm9wYWNpdHkgPSBmYWRlRm4oYW10KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICRzY29wZS5vblBhcnRpYWxTd2lwZSh7YW10OiBhbXR9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25Td2lwZVJpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5vblN3aXBlUmlnaHQoKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25Td2lwZUxlZnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLm9uU3dpcGVMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uVHJhbnNpdGlvblJpZ2h0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5vblRyYW5zaXRpb25SaWdodCgpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblRyYW5zaXRpb25MZWZ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5vblRyYW5zaXRpb25MZWZ0KCk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uVHJhbnNpdGlvbk91dDogZnVuY3Rpb24oYW10KSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFtdCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN3aXBlYWJsZUNhcmQub25UcmFuc2l0aW9uTGVmdCgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2lwZWFibGVDYXJkLm9uVHJhbnNpdGlvblJpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLm9uVHJhbnNpdGlvbk91dCh7YW10OiBhbXR9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25EZXN0cm95OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5vbkRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25TbmFwQmFjazogZnVuY3Rpb24oc3RhcnRYLCBzdGFydFksIHN0YXJ0Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICB2YXIgbGVmdFRleHQgPSBlbC5xdWVyeVNlbGVjdG9yKCcueWVzLXRleHQnKTtcclxuICAgICAgICAgICAgICB2YXIgcmlnaHRUZXh0ID0gZWwucXVlcnlTZWxlY3RvcignLm5vLXRleHQnKTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGNvbGxpZGUuYW5pbWF0aW9uKHtcclxuICAgICAgICAgICAgICAgIC8vICdsaW5lYXJ8ZWFzZXxlYXNlLWlufGVhc2Utb3V0fGVhc2UtaW4tb3V0fGN1YmljLWJlemVyKHgxLHkxLHgyLHkyKScsXHJcbiAgICAgICAgICAgICAgICAvLyBvciBmdW5jdGlvbih0LCBkdXJhdGlvbiksXHJcbiAgICAgICAgICAgICAgICAvLyBvciBhIGR5bmFtaWNzIGNvbmZpZ3VyYXRpb24gKHNlZSBiZWxvdylcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBwZXJjZW50OiAwLFxyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZTogZmFsc2VcclxuICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAuZWFzaW5nKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzcHJpbmcnLFxyXG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiAxNSxcclxuICAgICAgICAgICAgICAgIGZyaWN0aW9uOiAyNTAsXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsRm9yY2U6IGZhbHNlXHJcbiAgICAgICAgICAgICAgfSkgXHJcblxyXG4gICAgICAgICAgICAgIC5vbignc3RlcCcsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgICAgIC8vSGF2ZSB0aGUgZWxlbWVudCBzcHJpbmcgb3ZlciA0MDBweFxyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gZWwuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyAoc3RhcnRYIC0gc3RhcnRYKnYpICsgJ3B4LCAnICsgKHN0YXJ0WSAtIHN0YXJ0WSp2KSArICdweCwgMCkgcm90YXRlKCcgKyAoc3RhcnRSb3RhdGlvbiAtIHN0YXJ0Um90YXRpb24qdikgKyAncmFkKSc7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRUZXh0KSByaWdodFRleHQuc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFRleHQpIGxlZnRUZXh0LnN0eWxlLm9wYWNpdHkgPSAwO1xyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlLm9uU25hcEJhY2soKTtcclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICBhbmltYXRlU3ByaW5nVmlhQ3NzKGVsLCAwLCAwLjUsIDUwLCA3MDAsIDEwLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLnN0eWxlLnRyYW5zZm9ybSA9IGVsLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwwLDApJztcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICAkc2NvcGUuJHBhcmVudC5zd2lwZUNhcmQgPSBzd2lwZWFibGVDYXJkO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XSlcclxuXHJcbiAgLmRpcmVjdGl2ZSgndGRDYXJkcycsIFsnJHJvb3RTY29wZScsICckdGltZW91dCcsIGZ1bmN0aW9uKCRyb290U2NvcGUsICR0aW1lb3V0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0ZC1jYXJkc1wiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+JyxcclxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsICckZWxlbWVudCcsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgY2FyZHM7XHJcbiAgICAgICAgdmFyIGZpcnN0Q2FyZCwgc2Vjb25kQ2FyZCwgdGhpcmRDYXJkO1xyXG5cclxuICAgICAgICB2YXIgZXhpc3RpbmdDYXJkcywgY2FyZDtcclxuXHJcbiAgICAgICAgdmFyIGksIGo7XHJcblxyXG4gICAgICAgIHZhciBzb3J0Q2FyZHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGV4aXN0aW5nQ2FyZHMgPSAkZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCd0ZC1jYXJkJyk7XHJcblxyXG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgZXhpc3RpbmdDYXJkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjYXJkID0gZXhpc3RpbmdDYXJkc1tpXTtcclxuICAgICAgICAgICAgaWYoIWNhcmQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZihpID4gMCkge1xyXG4gICAgICAgICAgICAgIGNhcmQuc3R5bGUudHJhbnNmb3JtID0gY2FyZC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwgJyArIChpICogNCkgKyAncHgsIDApJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXJkLnN0eWxlLnpJbmRleCA9IChleGlzdGluZ0NhcmRzLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc29ydENhcmRzKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBicmluZ0NhcmRVcCA9IGZ1bmN0aW9uKGNhcmQsIGFtdCwgbWF4KSB7XHJcbiAgICAgICAgICB2YXIgcG9zaXRpb24sIG5ld1RvcDtcclxuICAgICAgICAgIHBvc2l0aW9uID0gY2FyZC5zdHlsZS50cmFuc2Zvcm0gfHwgY2FyZC5zdHlsZS53ZWJraXRUcmFuc2Zvcm07XHJcbiAgICAgICAgICBuZXdUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIG1heCAtIChtYXggKiBNYXRoLmFicyhhbXQpKSkpO1xyXG4gICAgICAgICAgY2FyZC5zdHlsZS50cmFuc2Zvcm0gPSBjYXJkLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLCAnICsgbmV3VG9wICsgJ3B4LCAwKSc7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJ0aWFsID0gZnVuY3Rpb24oYW10KSB7XHJcbiAgICAgICAgICBjYXJkcyA9ICRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RkLWNhcmQnKTtcclxuICAgICAgICAgIGZpcnN0Q2FyZCA9IGNhcmRzWzBdO1xyXG4gICAgICAgICAgc2Vjb25kQ2FyZCA9IGNhcmRzLmxlbmd0aCA+IDIgJiYgY2FyZHNbMV07XHJcbiAgICAgICAgICB0aGlyZENhcmQgPSBjYXJkcy5sZW5ndGggPiAzICYmIGNhcmRzWzJdO1xyXG5cclxuICAgICAgICAgIHNlY29uZENhcmQgJiYgYnJpbmdDYXJkVXAoc2Vjb25kQ2FyZCwgYW10LCA0KTtcclxuICAgICAgICAgIHRoaXJkQ2FyZCAmJiBicmluZ0NhcmRVcCh0aGlyZENhcmQsIGFtdCwgOCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgfV1cclxuICAgIH1cclxuICB9XSlcclxuXHJcbiAgLmZhY3RvcnkoJ1REQ2FyZERlbGVnYXRlJywgWyckcm9vdFNjb3BlJywgZnVuY3Rpb24oJHJvb3RTY29wZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcG9wQ2FyZDogZnVuY3Rpb24oJHNjb3BlLCBpc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgJHJvb3RTY29wZS4kZW1pdCgndGRDYXJkLnBvcCcsIGlzQW5pbWF0ZWQpO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRTd2lwZWFibGVDYXJkOiBmdW5jdGlvbigkc2NvcGUpIHtcclxuICAgICAgICByZXR1cm4gJHNjb3BlLnN3aXBlQ2FyZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbn0pKHdpbmRvdy5pb25pYyk7XHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9ib3dlcl9jb21wb25lbnRzXFxcXGlvbmljLWNvbnRyaWItdGluZGVyLWNhcmRzXFxcXGlvbmljLnRkY2FyZHMuanNcIixcIi9ib3dlcl9jb21wb25lbnRzXFxcXGlvbmljLWNvbnRyaWItdGluZGVyLWNhcmRzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXHJcbiAqIENyZWF0ZWQgYnkgb2xlZyBvbiA2LzMwLzIwMTUuXHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ2FjdGl2aXR5RGV0YWlscycsIFtdKVxyXG5cclxuICAgIC5kaXJlY3RpdmUoJ2FjdGl2aXR5JyxmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdyZXF1aXJlJzonXmRhdGEnLFxyXG4gICAgICAgICAgICAncmVzdHJpY3QnOidFJyxcclxuICAgICAgICAgICAgJ3Njb3BlJzp7XHJcbiAgICAgICAgICAgICAgICBvbmFjdGl2aXR5ZGV0YWlsc2luaXQ6JyZvbmFjdGl2aXR5ZGV0YWlsc2luaXQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICd0cmFuc2NsdWRlJzpmYWxzZSxcclxuICAgICAgICAgICAgJ2NvbnRyb2xsZXInOidhY3Rpdml0eUNvbnRyb2xsZXInLFxyXG4gICAgICAgICAgICAvLyd0ZW1wbGF0ZVVybCc6Jy4vYXBwL2NvbXBvbmVudHMvYWN0aXZpdHlEZXRhaWxzL2FjdGl2aXR5RGV0YWlscy52aWV3Lmh0bWwnLFxyXG4gICAgICAgICAgICAnbGluayc6ZnVuY3Rpb24oc2NvcGUsZWxlbWVudCxhdHRycyxkYXRhQ3RybCl7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5pbml0KGRhdGFDdHJsKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLm9uYWN0aXZpdHlkZXRhaWxzaW5pdCh7c2NvcGU6c2NvcGV9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KVxyXG4gICAgLmNvbnRyb2xsZXIoJ2FjdGl2aXR5Q29udHJvbGxlcicsWyckc2NvcGUnLCckaW9uaWNNb2RhbCcsZnVuY3Rpb24oJHNjb3BlLCRpb25pY01vZGFsKXtcclxuXHJcbiAgICAgICAgJHNjb3BlLmluaXQ9IGZ1bmN0aW9uIChkYXRhQ3RybCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWN0aXZpdHlEZXRhaWxzIGNvbXBvbmVudCBpbml0JyxkYXRhQ3RybCk7XHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhQ3RybD1kYXRhQ3RybDtcclxuXHJcbiAgICAgICAgICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgnLi9hcHAvY29tcG9uZW50cy9hY3Rpdml0eURldGFpbHMvYWN0aXZpdHlEZXRhaWxzLnZpZXcuaHRtbCcsIGZ1bmN0aW9uKCRpb25pY01vZGFsKSB7XHJcbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kYWwgPSAkaW9uaWNNb2RhbDtcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgLy8gVXNlIG91ciBzY29wZSBmb3IgdGhlIHNjb3BlIG9mIHRoZSBtb2RhbCB0byBrZWVwIGl0IHNpbXBsZVxyXG4gICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBhbmltYXRpb24gd2Ugd2FudCB0byB1c2UgZm9yIHRoZSBtb2RhbCBlbnRyYW5jZVxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiAnc2NhbGUtaW4nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5sb2FkYWN0aXZpdHk9ZnVuY3Rpb24oYWN0aXZpdHkpe1xyXG4gICAgICAgICAgICAkc2NvcGUuYWN0aXZpdHk9YWN0aXZpdHk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWN0aXZpdHlcIiwgJHNjb3BlLmFjdGl2aXR5KTtcclxuICAgICAgICAgICAgJHNjb3BlLm1vZGFsLnNob3coKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1dKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY29tcG9uZW50c1xcXFxhY3Rpdml0eURldGFpbHNcXFxcYWN0aXZpdHlEZXRhaWxzLm1vZHVsZS5qc1wiLFwiL2NvbXBvbmVudHNcXFxcYWN0aXZpdHlEZXRhaWxzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXHJcbiAqIENyZWF0ZWQgYnkgb2xlZyBvbiA2LzMwLzIwMTUuXHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ2RhdGFDb3JlJywgWydkaXNjb3ZlckFjdGl2aXRpZXMnLCdhY3Rpdml0eURldGFpbHMnXSlcclxuXHJcbiAgICAuZGlyZWN0aXZlKCdkYXRhJyxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ3Jlc3RyaWN0JzonRScsXHJcbiAgICAgICAgICAgICAgICAnc2NvcGUnOntcclxuXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJ3RyYW5zY2x1ZGUnOmZhbHNlLFxyXG4gICAgICAgICAgICAgICAgJ2NvbnRyb2xsZXInOidkYXRhQ29udHJvbGxlcicsXHJcbiAgICAgICAgICAgICAgICAnbGluayc6ZnVuY3Rpb24oc2NvcGUsZWxlbWVudCxhdHRycyl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuaW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIC5jb250cm9sbGVyKCdkYXRhQ29udHJvbGxlcicsWyckc2NvcGUnLCckaHR0cCcsJ2NvbmZpZycsJyRxJyxmdW5jdGlvbigkc2NvcGUsJGh0dHAsY29uZmlnLCRxKXtcclxuICAgICAgICAgICAgdmFyIHNlbGY9dGhpcztcclxuICAgICAgICAgICAgdGhpcy5pdGVtcz1bXTtcclxuXHJcbiAgICAgICAgICAgICRzY29wZS5pbml0PSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZGF0YUNvcmUgY29tcG9uZW50IGluaXQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAkaHR0cC5nZXQoY29uZmlnLmRldmVsb3BtZW50RGJVcmwrJ2FjdGl2aXR5X3VuX3NlYXJjaCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkYXRhQ29yZTogc3VjY2VzcyBnZXQgYWxsIGFjdGl2aXRpZXNcIiwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXRlbXM9ZGF0YS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmVycm9yKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgZ2V0IGFsbCBhY3Rpdml0aWVzXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHEucHJvbWlzZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy90aGlzLml0ZW1zID0gJGh0dHAuZ2V0KGNvbmZpZy5kZXZlbG9wbWVudERiVXJsKydhY3Rpdml0eV91bl9zZWFyY2gnKVxyXG4gICAgICAgICAgICAvLyAgICAuc3VjY2VzcyhmdW5jdGlvbihkYXRhLCBzdGF0dXMsIGhlYWRlcnMsIGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coXCJkYXRhQ29yZTogc3VjY2VzcyBnZXQgYWxsIGFjdGl2aXRpZXNcIiwgZGF0YSk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAkc2NvcGUuaXRlbXM9ZGF0YTtcclxuICAgICAgICAgICAgLy8gICAgfSlcclxuICAgICAgICAgICAgLy8gICAgLmVycm9yKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIGdldCBhbGwgYWN0aXZpdGllc1wiKVxyXG4gICAgICAgICAgICAvLyAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vdGhpcy5nZXRBY3Rpdml0eT1mdW5jdGlvbihpZCl7XHJcbiAgICAgICAgICAgIC8vICAgIHZhciBpdGVtcyA9ICRzY29wZS5pdGVtcy5kYXRhO1xyXG4gICAgICAgICAgICAvLyAgICBmb3IodmFyIGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgLy8gICAge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgaWYoaXRlbXNbaV0uX2lkPT1pZClcclxuICAgICAgICAgICAgLy8gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICByZXR1cm4gaXRlbXNbaV07XHJcbiAgICAgICAgICAgIC8vICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICAgIH1cclxuICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuZ2V0QWN0aXZpdGllcz1mdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICAgY29uc29sZS5sb2coXCJjb25maWdcIiwgY29uZmlnLmRldmVsb3BtZW50RGJVcmwpO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgICByZXR1cm4gJGh0dHAuZ2V0KGNvbmZpZy5kZXZlbG9wbWVudERiVXJsKydhY3Rpdml0eV91bl9zZWFyY2gnKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZGF0YUNvcmU6IHN1Y2Nlc3MgZ2V0IGFsbCBhY3Rpdml0aWVzXCIsIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8gICAgICAgIC5lcnJvcihmdW5jdGlvbihkYXRhLCBzdGF0dXMsIGhlYWRlcnMsIGNvbmZpZykge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJlcnJvciBnZXQgYWxsIGFjdGl2aXRpZXNcIilcclxuICAgICAgICAgICAgLy8gICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyAgICAvL3JldHVybiBbe2FjdGl2aXR5OiAnYWN0aXZpdHkxJ30sIHthY3Rpdml0eTogJ2FjdGl2aXR5Mid9XTtcclxuICAgICAgICAgICAgLy99XHJcblxyXG4gICAgICAgIH1dKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY29tcG9uZW50c1xcXFxkYXRhQ29yZVxcXFxkYXRhQ29yZS5tb2R1bGUuanNcIixcIi9jb21wb25lbnRzXFxcXGRhdGFDb3JlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXHJcbiAqIENyZWF0ZWQgYnkgb2xlZyBvbiA2LzMwLzIwMTUuXHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ2Rpc2NvdmVyQWN0aXZpdGllcycsIFsnaW9uaWMuY29udHJpYi51aS50aW5kZXJDYXJkcyddKVxyXG5cclxuICAgIC5kaXJlY3RpdmUoJ2Rpc2NvdmVyJyxmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdyZXF1aXJlJzonXmRhdGEnLFxyXG4gICAgICAgICAgICAncmVzdHJpY3QnOidFJyxcclxuICAgICAgICAgICAgJ3Njb3BlJzp7XHJcbiAgICAgICAgICAgICAgICBvbmRpc2NvdmVyYWN0aXZpdGllc2luaXQ6JyZvbmRpc2NvdmVyYWN0aXZpdGllc2luaXQnLFxyXG4gICAgICAgICAgICAgICAgb25hY3Rpdml0eWRldGFpbDonJm9uYWN0aXZpdHlkZXRhaWwnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICd0cmFuc2NsdWRlJzpmYWxzZSxcclxuICAgICAgICAgICAgJ2NvbnRyb2xsZXInOidkaXNjb3ZlckNvbnRyb2xsZXInLFxyXG4gICAgICAgICAgICAndGVtcGxhdGVVcmwnOicuL2FwcC9jb21wb25lbnRzL2Rpc2NvdmVyQWN0aXZpdGllcy9kaXNjb3ZlckFjdGl2aXRpZXMudmlldy5odG1sJyxcclxuICAgICAgICAgICAgJ2xpbmsnOmZ1bmN0aW9uKHNjb3BlLGVsZW1lbnQsYXR0cnMsZGF0YUN0cmwpe1xyXG5cclxuICAgICAgICAgICAgICAgIHNjb3BlLmluaXQoZGF0YUN0cmwpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZGF0YUN0cmwuaXRlbXMudGhlbihmdW5jdGlvbihkYXRhKXtcclxuICAgICAgICAgICAgICAgIC8vICAgIHNjb3BlLmluaXQoZGF0YS5kYXRhLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RhdGFDdHJsLmdldEFjdGl2aXRpZXMoKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgLnN1Y2Nlc3MoZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKFwiZGlzY292ZXJBY3Rpdml0aWVzOiBzdWNjZXNzIGdldCBhbGwgYWN0aXZpdGllc1wiLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgc2NvcGUuaW5pdChyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIC8vICAgIH0pXHJcbiAgICAgICAgICAgICAgICAvLyAgICAuZXJyb3IoZnVuY3Rpb24ocmVzcG9uc2Upe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKFwiZGlzY292ZXJBY3Rpdml0aWVzOiBlcnJvciBnZXQgYWxsIGFjdGl2aXRpZXNcIiwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc2NvcGUub25kaXNjb3ZlcmFjdGl2aXRpZXNpbml0KHtzY29wZTpzY29wZX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pXHJcbiAgICAuY29udHJvbGxlcignZGlzY292ZXJDb250cm9sbGVyJyxbJyRzY29wZScsZnVuY3Rpb24oJHNjb3BlKXtcclxuXHJcbiAgICAgICAgJHNjb3BlLmluaXQ9IGZ1bmN0aW9uIChkYXRhQ29yZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGlzY292ZXJBY3Rpdml0aWVzIGNvbXBvbmVudCBpbml0JyxkYXRhQ29yZSk7XHJcbiAgICAgICAgICAgICRzY29wZS5kYXRhQ29yZT1kYXRhQ29yZTtcclxuICAgICAgICAgICAgLy8kc2NvcGUuYWN0aXZpdGllcz1hY3Rpdml0aWVzO1xyXG4gICAgICAgICAgICAvLyRzY29wZS5hY3Rpdml0aWVzLnNwbGljZSg1LCAzOCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJHNjb3BlLmNhcmRTd2lwZWRMZWZ0PSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNhcmQgXCIraW5kZXgrXCIgc3dpcGVkIGxlZnQgXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5jYXJkU3dpcGVkUmlnaHQ9IGZ1bmN0aW9uKGluZGV4LGlkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FyZCBcIitpbmRleCtcIiBzd2lwZWQgcmlnaHQgXCIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5jYXJkRGVzdHJveWVkID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbmRleFwiLGluZGV4KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJiZWZvcmUgc2xpY2VcIiwgJHNjb3BlLmRhdGFDb3JlLml0ZW1zKTtcclxuICAgICAgICAgICAgJHNjb3BlLmRhdGFDb3JlLml0ZW1zLnNsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZnRlciBzbGljZVwiLCAkc2NvcGUuZGF0YUNvcmUuaXRlbXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5vcGVuQWN0aXZpdHk9ZnVuY3Rpb24oYWN0aXZpdHkpe1xyXG4gICAgICAgICAgICAkc2NvcGUub25hY3Rpdml0eWRldGFpbCh7YWN0aXZpdHk6YWN0aXZpdHl9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH1dKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvY29tcG9uZW50c1xcXFxkaXNjb3ZlckFjdGl2aXRpZXNcXFxcZGlzY292ZXJBY3Rpdml0aWVzLm1vZHVsZS5qc1wiLFwiL2NvbXBvbmVudHNcXFxcZGlzY292ZXJBY3Rpdml0aWVzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXHJcbiAqIENyZWF0ZWQgYnkgb2xlZyBvbiA2LzMwLzIwMTUuXHJcbiAqL1xyXG5cclxuYW5ndWxhci5tb2R1bGUoJ21haW4nLCBbJ2RhdGFDb3JlJ10pXHJcblxyXG4gICAgLmRpcmVjdGl2ZSgnbWFpbicsZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAncmVzdHJpY3QnOidFJyxcclxuICAgICAgICAgICAgJ3Njb3BlJzp7XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAndHJhbnNjbHVkZSc6ZmFsc2UsXHJcbiAgICAgICAgICAgICdjb250cm9sbGVyJzonbWFpbkNvbnRyb2xsZXInLFxyXG4gICAgICAgICAgICAndGVtcGxhdGVVcmwnOicuL2FwcC9jb21wb25lbnRzL21haW4vbWFpbi52aWV3Lmh0bWwnLFxyXG4gICAgICAgICAgICAnbGluayc6ZnVuY3Rpb24oc2NvcGUsZWxlbWVudCxhdHRycyl7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5pbml0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG4gICAgLmNvbnRyb2xsZXIoJ21haW5Db250cm9sbGVyJyxbJyRzY29wZScsZnVuY3Rpb24oJHNjb3BlKXtcclxuXHJcbiAgICAgICAgJHNjb3BlLnNob3dEZXRhaWxzPWZhbHNlO1xyXG5cclxuICAgICAgICAkc2NvcGUuaW5pdD0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbWFpbiBjb21wb25lbnQgaW5pdCcpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgICRzY29wZS5vbmRpc2NvdmVyYWN0aXZpdGllc2luaXQ9ZnVuY3Rpb24oZGlzY292ZXJBY3Rpdml0aWVzKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaXNjb3ZlckFjdGl2aXRpZXMgaW5pdCBpbiBNQUlOXCIpO1xyXG4gICAgICAgICAgICAkc2NvcGUuZGlzY292ZXJBY3Rpdml0aWVzPWRpc2NvdmVyQWN0aXZpdGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRzY29wZS5vbmFjdGl2aXR5ZGV0YWlsc2luaXQ9ZnVuY3Rpb24oYWN0aXZpdHlEZXRhaWxzKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJhY3Rpdml0eURldGFpbHMgaW5pdCBpbiBNQUlOXCIpO1xyXG4gICAgICAgICAgICAkc2NvcGUuYWN0aXZpdHlEZXRhaWxzPWFjdGl2aXR5RGV0YWlscztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICRzY29wZS5vbmFjdGl2aXR5ZGV0YWlsPWZ1bmN0aW9uKGFjdGl2aXR5KXtcclxuICAgICAgICAgICAgJHNjb3BlLnNob3dEZXRhaWxzPXRydWU7XHJcbiAgICAgICAgICAgICRzY29wZS5hY3Rpdml0eURldGFpbHMubG9hZGFjdGl2aXR5KGFjdGl2aXR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfV0pO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJWQ21Fc3dcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9jb21wb25lbnRzXFxcXG1haW5cXFxcbWFpbi5tb2R1bGUuanNcIixcIi9jb21wb25lbnRzXFxcXG1haW5cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKipcclxuICogQ3JlYXRlZCBieSBvbGVnIG9uIDYvMzAvMjAxNS5cclxuICovXHJcblxyXG5yZXF1aXJlKCcuL3NoYXJlZC9jb25maWcvY29uZmlnLm1vZHVsZS5qcycpO1xyXG5yZXF1aXJlKCcuL2NvbXBvbmVudHMvYWN0aXZpdHlEZXRhaWxzL2FjdGl2aXR5RGV0YWlscy5tb2R1bGUuanMnKTtcclxucmVxdWlyZSgnLi9jb21wb25lbnRzL2Rpc2NvdmVyQWN0aXZpdGllcy9kaXNjb3ZlckFjdGl2aXRpZXMubW9kdWxlLmpzJyk7XHJcbnJlcXVpcmUoJy4vY29tcG9uZW50cy9kYXRhQ29yZS9kYXRhQ29yZS5tb2R1bGUuanMnKTtcclxucmVxdWlyZSgnLi9jb21wb25lbnRzL21haW4vbWFpbi5tb2R1bGUuanMnKTtcclxuXHJcbmdsb2JhbC5jb2xsaWRlPXJlcXVpcmUoJy4vYm93ZXJfY29tcG9uZW50cy9jb2xsaWRlL2NvbGxpZGUuanMnKTtcclxucmVxdWlyZSgnLi9ib3dlcl9jb21wb25lbnRzL2lvbmljLWNvbnRyaWItdGluZGVyLWNhcmRzL2lvbmljLnRkY2FyZHMuanMnKTtcclxuXHJcblxyXG52YXIgYXBwPWFuZ3VsYXIubW9kdWxlKCdzdGFydGVyJywgWydpb25pYycsJ2NvbmZpZycsJ2RhdGFDb3JlJywnbWFpbiddKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZmFrZV80YjU4MmY4Ny5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qKlxyXG4gKiBDcmVhdGVkIGJ5IG9sZWcgb24gNi8yOS8yMDE1LlxyXG4gKi9cclxuICAgIGFuZ3VsYXIubW9kdWxlKCdjb25maWcnLCBbXSlcclxuICAgIC5jb25zdGFudCgnY29uZmlnJywge1xyXG4gICAgICAgIHB1c2g6IHtcclxuICAgICAgICAgICAgaW9zOiB7XHJcbiAgICAgICAgICAgICAgICBiYWRnZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNvdW5kOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWxlcnQ6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYW5kcm9pZDoge1xyXG4gICAgICAgICAgICAgICAgXCJzZW5kZXJJRFwiOiBcIjU5MzM2MzIyOTUxXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VuZGVySUQ6JzU5MzM2MzIyOTUxJyxcclxuICAgICAgICBmYkFwcElkOic0NjYyNjkzNTY3NTExNzMnLFxyXG4gICAgICAgIHByb2R1Y3Rpb25EYlVybDonaHR0cHM6Ly9zYWx0eS1wZWFrLTI1MTUuaGVyb2t1YXBwLmNvbS8nLFxyXG4gICAgICAgIGRldmVsb3BtZW50RGJVcmw6J2h0dHBzOi8vZmxvYXRpbmctZGVwdGhzLTIyNDAuaGVyb2t1YXBwLmNvbS8nXHJcbiAgICB9KTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvc2hhcmVkXFxcXGNvbmZpZ1xcXFxjb25maWcubW9kdWxlLmpzXCIsXCIvc2hhcmVkXFxcXGNvbmZpZ1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXFxcXGluZGV4LmpzXCIsXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiVkNtRXN3XCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi5cXFxcbm9kZV9tb2R1bGVzXFxcXGd1bHAtYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcYnVmZmVyXFxcXG5vZGVfbW9kdWxlc1xcXFxiYXNlNjQtanNcXFxcbGliXFxcXGI2NC5qc1wiLFwiLy4uXFxcXG5vZGVfbW9kdWxlc1xcXFxndWxwLWJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJ1ZmZlclxcXFxub2RlX21vZHVsZXNcXFxcYmFzZTY0LWpzXFxcXGxpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uXFxcXG5vZGVfbW9kdWxlc1xcXFxndWxwLWJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJ1ZmZlclxcXFxub2RlX21vZHVsZXNcXFxcaWVlZTc1NFxcXFxpbmRleC5qc1wiLFwiLy4uXFxcXG5vZGVfbW9kdWxlc1xcXFxndWxwLWJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJ1ZmZlclxcXFxub2RlX21vZHVsZXNcXFxcaWVlZTc1NFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIlZDbUVzd1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uXFxcXG5vZGVfbW9kdWxlc1xcXFxndWxwLWJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXHByb2Nlc3NcXFxcYnJvd3Nlci5qc1wiLFwiLy4uXFxcXG5vZGVfbW9kdWxlc1xcXFxndWxwLWJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXGJyb3dzZXJpZnlcXFxcbm9kZV9tb2R1bGVzXFxcXHByb2Nlc3NcIikiXX0=
